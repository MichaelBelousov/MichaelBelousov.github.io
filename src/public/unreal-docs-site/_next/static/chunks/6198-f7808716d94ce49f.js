"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[6198],{6198:function(e,t,n){n.d(t,{Pu:function(){return l},ZP:function(){return E},Jt:function(){return x}});var o=n(159),a=n(91164),i=n(67294),r=n(3905),s=["components"],l=(i.createElement,{title:"Changed Elements API Tutorial",tile:{name:"Changed Elements API Tutorial",description:"This tutorial will teach you how to use the Changed Elements API to visualize change in your iTwin Application",thumbnail:"/images/changed-elements-thumbnail.png",href:"/tutorials/changed-elements-api",durationInMinutes:45,relatedApiIds:["changedelements","visualization"]}}),d=function(e){return function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",t)}},h=d("Introduction"),c=d("TutorialSection"),p=d("LinkButton"),m=d("NodeJsIcon"),u=d("GitIcon"),g=d("Title"),w=d("CodeBlock"),k=d("GoogleChromeIcon"),f=d("VSCodeIcon"),b=d("PostmanIcon"),y=d("Alert"),C=d("ContinueLearningSection"),v=d("TileList"),T=d("ResourceTile"),I={metadata:l};function E(e){var t=e.components,n=(0,a.Z)(e,s);return(0,r.kt)("wrapper",(0,o.Z)({},I,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)(h,{skillLevel:"Basic",durationInMinutes:"45",summaryImageSrc:"/images/changed-elements-header.png",mdxType:"Introduction"},(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"The Changed Elements API is a REST API that allows the consumer to inspect what elements have changed in an iModel between two versions of the iModel. In this tutorial, we will explore using the API operations and we will write an iTwin.js application to visualize change.")),(0,r.kt)(c,{mdxType:"TutorialSection"},(0,r.kt)("h2",{id:"1-set-up-your-environment"},"1. Set up your environment"),(0,r.kt)("p",null,"To do this tutorial, it is recommended that you do the ",(0,r.kt)("a",{parentName:"p",href:"/tutorials/web-application-quick-start/"},"Web Application Quick Start tutorial")," first. This tutorial expects that you have a registered application as shown in the quick start tutorial.")),(0,r.kt)(c,{subSection:!0,actions:[(0,r.kt)(p,{href:"https://nodejs.org",target:"_blank",title:"Node.js",icon:(0,r.kt)(m,{mdxType:"NodeJsIcon"}),mdxType:"LinkButton"}),(0,r.kt)(p,{href:"https://git-scm.com/downloads",target:"_blank",title:"Git",icon:(0,r.kt)(u,{mdxType:"GitIcon"}),mdxType:"LinkButton"}),(0,r.kt)(g,{mdxType:"Title"},"Clone starting point for tutorial"),(0,r.kt)(w,{language:"bash",code:"git clone https://github.com/iTwin/changed-elements-tutorial -b start",mdxType:"CodeBlock"}),(0,r.kt)(g,{mdxType:"Title"},"Finished tutorial application"),(0,r.kt)(w,{language:"bash",code:"git clone https://github.com/iTwin/changed-elements-tutorial",mdxType:"CodeBlock"})],mdxType:"TutorialSection"},(0,r.kt)("h3",{id:"11-required-materials"},"1.1 Required materials"),(0,r.kt)("h5",{id:"a-hrefhttpsnodejsorg-target_blanknodejs-14x-lts-versiona"},(0,r.kt)("a",{href:"https://nodejs.org",target:"_blank"},"Node.js (14.x LTS version)")),(0,r.kt)("p",null,"This tool provides the backend JavaScript runtime necessary for your computer to read and render code appropriately. It also allows you to run NPM command line (required for every iTwin project)."),(0,r.kt)("h5",{id:"a-hrefhttpsgit-scmcomdownloads-target_blankgita"},(0,r.kt)("a",{href:"https://git-scm.com/downloads",target:"_blank"},"Git")),(0,r.kt)("p",null,"This is the source code control system for the iTwin repositories."),(0,r.kt)("h5",{id:"a-hrefhttpsgithubcomitwinchanged-elements-tutorial-target_blanktutorial-repositorya"},(0,r.kt)("a",{href:"https://github.com/iTwin/changed-elements-tutorial",target:"_blank"},"Tutorial Repository")),(0,r.kt)("p",null,"This is the github repository that you will use in this tutorial. You should clone the ",(0,r.kt)("inlineCode",{parentName:"p"},"start")," branch as a starting point to follow along. If at any point you are unsure on how to setup the code demonstrated in the snippets, or just want to take a shortcut, the repository\u2019s ",(0,r.kt)("inlineCode",{parentName:"p"},"main")," branch contains the finished tutorial application.")),(0,r.kt)(c,{subSection:!0,actions:[(0,r.kt)(p,{href:"https://www.google.com/chrome/",target:"_blank",title:"Google Chrome",icon:(0,r.kt)(k,{mdxType:"GoogleChromeIcon"}),mdxType:"LinkButton"}),(0,r.kt)(p,{href:"https://code.visualstudio.com/",target:"_blank",title:"Visual Studio Code",icon:(0,r.kt)(f,{mdxType:"VSCodeIcon"}),mdxType:"LinkButton"}),(0,r.kt)(p,{href:"https://www.postman.com/downloads/",target:"_blank",title:"Postman",icon:(0,r.kt)(b,{mdxType:"PostmanIcon"}),mdxType:"LinkButton"})],mdxType:"TutorialSection"},(0,r.kt)("h3",{id:"12-suggested-materials"},"1.2 Suggested materials"),(0,r.kt)("h5",{id:"a-hrefhttpswwwgooglecomchrome-target_blankgoogle-chromea"},(0,r.kt)("a",{href:"https://www.google.com/chrome/",target:"_blank"},"Google Chrome")),(0,r.kt)("p",null,"This software can help you to develop and debug frontend JavaScript problems."),(0,r.kt)("h5",{id:"a-hrefhttpscodevisualstudiocom-target_blankvisual-studio-codea"},(0,r.kt)("a",{href:"https://code.visualstudio.com/",target:"_blank"},"Visual Studio Code")),(0,r.kt)("p",null,"This is our recommended editor and debugger tool for developing iTwin.js applications. It is free, open source and includes a GUI for working with GIT."),(0,r.kt)("h5",{id:"a-hrefhttpswwwpostmancomdownloads-target_blankpostmana"},(0,r.kt)("a",{href:"https://www.postman.com/downloads/",target:"_blank"},"Postman")),(0,r.kt)("p",null,"If you want to test the REST API calls directly, you can use ",(0,r.kt)("a",{parentName:"p",href:"https://www.postman.com/downloads/"},"Postman")," or any other solution capable of sending HTTP requests. If you do it this way, you will require an authorization token for the requests to work."),(0,r.kt)("p",null,"To learn more about how authentication and authorization works in an iTwin powered application, check out the full ",(0,r.kt)("a",{parentName:"p",href:"/apis/overview/authorization/"},"documentation")," on how to obtain the token.")),(0,r.kt)(c,{mdxType:"TutorialSection"},(0,r.kt)("h2",{id:"2-overview-of-changed-elements-api"},"2. Overview of Changed Elements API"),(0,r.kt)("p",null,"Before diving into writing code to leverage the changed elements API with an iTwin.js application, let\u2019s take a look at the operations that are available in the API first")),(0,r.kt)(c,{subSection:!0,mdxType:"TutorialSection"},(0,r.kt)("h3",{id:"21-enabling-change-tracking"},"2.1 Enabling Change Tracking"),(0,r.kt)("p",null,"This is the first operation of the API and is used to enable change tracking of an iModel."),(0,r.kt)("p",null,"The API requires the ",(0,r.kt)("inlineCode",{parentName:"p"},"changedelements:modify")," scope to be added to your App. It can be added to your apps in the ",(0,r.kt)("a",{parentName:"p",href:"/my-apps/"},"Developer Portal"),".")),(0,r.kt)(c,{subSection:!0,mdxType:"TutorialSection"},(0,r.kt)("h4",{id:"211-what-is-change-tracking-and-why-do-we-need-it"},"2.1.1 What is change tracking and why do we need it?"),(0,r.kt)("p",null,"An iModel evolves over time. Every time a design file is changed and the iModel is synchronized, new ",(0,r.kt)("a",{parentName:"p",href:"https://www.itwinjs.org/reference/imodelhub-client/imodelhubclient/changeset/?term=changeset"},"Changesets")," are published to the iModel, updating the iModel data."),(0,r.kt)("p",null,"An iModel may contain graphical elements that are related to business data. For example, let\u2019s think about a piece of equipment:"),(0,r.kt)("div",{style:{marginTop:"16px",marginBottom:"16px"}},(0,r.kt)("img",{src:"../../images/changed-elements-related-property.png",style:{margin:"auto"}})),(0,r.kt)("p",null,"This equipment may be displayed in an iModel with a bare-bones ",(0,r.kt)("a",{parentName:"p",href:"https://www.itwinjs.org/reference/imodeljs-backend/elements/geometricelement/?term=geometric+element"},"Geometric Element"),", however, business data that relates to it (like the pump diameter in the image above), exists under the properties of a different non-graphical element."),(0,r.kt)("p",null,"A changeset may contain changes to the equipment\u2019s related pump diameter property, but the geometric counterpart of the equipment will not contain a change. To be able to find which elements relate to which change, you can use the Changed Elements API."),(0,r.kt)("p",null,"The Changed Elements API will track the iModel for changes, and when a ",(0,r.kt)("a",{parentName:"p",href:"https://www.itwinjs.org/learning/imodelhub/versions/?term=named+version"},"Named Version")," is created, the API will find all related elements that have changed in each of the changesets and store a summary of them in the cloud.")),(0,r.kt)(c,{subSection:!0,actions:[(0,r.kt)(g,{mdxType:"Title"},"Example HTTP Request for Enable Change Tracking Operation"),(0,r.kt)(w,{language:"http",code:'PUT https://api.bentley.com/changedelements/tracking HTTP/1.1\nAuthorization: Bearer JWT_TOKEN\nContent-Type: application/json\n\n{\n  "enable":true,\n  "iModelId":"myIModelId",\n  "projectId":"myProjectId"\n}',mdxType:"CodeBlock"})],mdxType:"TutorialSection"},(0,r.kt)("h4",{id:"212-how-do-i-enable-tracking-in-the-changed-elements-api"},"2.1.2 How do I enable tracking in the Changed Elements API?"),(0,r.kt)("p",null,"The API has an operation to enable the changed elements feature for an iModel. As mentioned before, for this operation to work, your App needs to have the scope: ",(0,r.kt)("inlineCode",{parentName:"p"},"changedelements:modify"),"."),(0,r.kt)("p",null,"Here is an example request that shows how to enable the APIs change tracking for an iModel, you would just need to replace the project Id, iModel Id and authorization token with your own."),(0,r.kt)("p",null,"The body should contain a JSON object with a ",(0,r.kt)("inlineCode",{parentName:"p"},"enable")," property, and it must be either true or false as shown in the example above."),(0,r.kt)("p",null,"Here is the ",(0,r.kt)("a",{parentName:"p",href:"/apis/changed-elements/operations/enable-change-tracking/"},"documentation")," for this operation.")),(0,r.kt)(c,{subSection:!0,mdxType:"TutorialSection"},(0,r.kt)("h4",{id:"213-my-imodel-is-being-tracked-for-change-now-what"},"2.1.3 My iModel is being tracked for change, now what?"),(0,r.kt)("p",null,"Once change tracking is enabled for your iModel, whenever a new ",(0,r.kt)("a",{parentName:"p",href:"https://www.itwinjs.org/learning/imodelhub/versions/?term=named+version"},"Named Version")," gets created, either by a design application or a ",(0,r.kt)("a",{parentName:"p",href:"https://www.itwinjs.org/learning/imodel-connectors/?term=connector"},"Connector"),", the API will process the changesets and store the results of what elements have changed in your iModel."),(0,r.kt)("p",null,"This operation can take time, and the time it takes is dependent on data complexity and size. It is recommended to use a small iModel to do this tutorial if you are following along, as a very large iModel may take hours to process if it has never been processed and has a lot of data.")),(0,r.kt)(c,{subSection:!0,mdxType:"TutorialSection"},(0,r.kt)("h3",{id:"22-getting-changed-elements"},"2.2 Getting Changed Elements"),(0,r.kt)("p",null,"The next operation allows us to query the API to get the elements that have changed after processing is ready. To use this operation, you must provide the start and end changeset Ids that you want to obtain results for. To get changeset Ids, you can use ",(0,r.kt)("a",{parentName:"p",href:"/apis/imodels/operations/get-imodel-changesets/"},"Get iModel Changesets API"),"."),(0,r.kt)("p",null,"The API requires the ",(0,r.kt)("inlineCode",{parentName:"p"},"changedelements:read")," scope to be added to your App. It can be added to your apps in the ",(0,r.kt)("a",{parentName:"p",href:"/my-apps/"},"Developer Portal"))),(0,r.kt)(c,{subSection:!0,actions:[(0,r.kt)(g,{mdxType:"Title"},"Example HTTP Request for Get Comparison Operation"),(0,r.kt)(w,{language:"http",code:"GET https://api.bentley.com/changedelements/comparison?projectId=myProjectId&iModelId=myIModelId&startChangesetId=myStartChangesetId&endChangesetId=myEndChangesetId HTTP/1.1\nAuthorization: Bearer JWT_TOKEN\nContent-Type: application/json",mdxType:"CodeBlock"}),(0,r.kt)(g,{mdxType:"Title"},"Example result from the Get Comparison Operation"),(0,r.kt)(w,{language:"json",code:'{\n  "changedElements": {\n    "elements":["0x30000000f69"],\n    "classIds":["0x670"],\n    "opcodes":[23],\n    "modelIds":["0x20000000002"],\n    "type":[1],\n    "properties":[["UserLabel"]],\n    "oldChecksums":[[1448094486]],\n    "newChecksums":[[362149254]],\n    "parentIds":["0"],\n    "parentClassIds":["0"]\n  }\n}',mdxType:"CodeBlock"})],mdxType:"TutorialSection"},(0,r.kt)("h4",{id:"221-using-the-api-to-get-changed-elements"},"2.2.1 Using the API to get changed elements"),(0,r.kt)("p",null,"Here is an example request that shows how to get the changed elements between two changesets, ensure to replace the project Id, iModel Id, start changeset Id, end changeset Id and authorization token with your own."),(0,r.kt)("p",null,"This operation will return a JSON object that contains which elements have changed between the two given changeset Ids. The returned JSON corresponds to the ",(0,r.kt)("a",{parentName:"p",href:"https://www.itwinjs.org/reference/imodeljs-common/entities/changedelements/"},"ChangedElements")," interface. We will explore the format a bit more in the ",(0,r.kt)("a",{parentName:"p",href:"#41-changed-elements-json"},"Changed Elements JSON Section"),". Here\u2019s an example of the data returned for a single element that changed:"),(0,r.kt)(y,{type:"informational",mdxType:"Alert"},"The results are inclusive to both start and end changesets. This means that the changes found in both changesets will be contained in the results. This is important to think about because if you have an iModel with 2 Named Versions, A and B, and you want to get what has changed between A and B, you should *not* include A's changeset in the query. Consider the following example:",(0,r.kt)("div",{style:{marginTop:"16px",marginBottom:"16px"}},(0,r.kt)("img",{src:"../../images/changed-elements-changeset-example.png",style:{margin:"auto"}})),(0,r.kt)("p",null,"In the example above, even though Changeset 2 is the changeset related to Named Version A, to get what has changed between A and B, start changeset should be Changeset 3 and end changeset should be Changeset 4, as Changeset 2 is already applied to the iModel in Named Version A."),(0,r.kt)("p",null,"Another thing to keep in mind is that if you want to obtain changed elements for a single changeset, since the range is inclusive, you can provide the same changeset Id for start and end changesets, and it will return the elements for the given changeset."),(0,r.kt)("p",null,"Here\u2019s the ",(0,r.kt)("a",{style:{textDecoration:"underline"},href:"/apis/changed-elements/operations/get-comparison/"},"documentation")," for this operation."))),(0,r.kt)(c,{mdxType:"TutorialSection"},(0,r.kt)("h2",{id:"3-putting-it-to-work"},"3. Putting it to work"),(0,r.kt)("p",null,"Now that we have covered how the API works, we will use it to create a simple application that can visualize change."),(0,r.kt)("p",null,"We will implement a simple widget that will allow us to use both operations of the changed elements API. It will have a button to enable change tracking, a dropdown that will allow us to pick a named version and another button to visualize the differences between the current version and the one selected in the dropdown.")),(0,r.kt)(c,{subSection:!0,actions:[(0,r.kt)(g,{mdxType:"Title"},"Necessary imports"),(0,r.kt)(w,{language:"typescript",code:'import { Version } from "@bentley/imodelhub-client";\nimport { AuthorizedFrontendRequestContext, IModelApp, IModelConnection } from "@bentley/imodeljs-frontend";\nimport { Button } from "@bentley/ui-core";\nimport React, { useEffect, useState } from "react";\nimport { useCallback } from "react";\nimport Select from "react-select";\nimport "./ChangedElementsWidget.scss";',mdxType:"CodeBlock"}),(0,r.kt)(g,{mdxType:"Title"},"Write a react hook for getting named versions"),(0,r.kt)(w,{language:"typescript",code:'function useNamedVersions(props: { iModel: IModelConnection | undefined }) {\n  const [versions, setVersions] = useState<Version[]>();\n\n  // Load named versions that can be used for comparison\n  useEffect(() => {\n    const loadChangesets = async () => {\n      // Ensure we have a proper iModel with an iModel Id\n      if (props.iModel?.iModelId === undefined) {\n        console.error("iModel is not valid");\n        return;\n      }\n      // Create request context for querying named versions\n      const requestContext = await AuthorizedFrontendRequestContext.create();\n      // Get the versions and set them to our state\n      setVersions(await IModelApp.iModelClient.versions.get(requestContext, props.iModel.iModelId));\n    };\n    // Call the asynchronous function to load named versions\n    loadChangesets();\n  }, [props.iModel]);\n\n  return versions;\n}',mdxType:"CodeBlock"}),(0,r.kt)(g,{mdxType:"Title"},"Write the widget UI component"),(0,r.kt)(w,{language:"typescript",code:'export interface ChangedElementsWidgetProps {\n  iModel: IModelConnection | undefined;\n}\n\nexport function ChangedElementsWidget(props: ChangedElementsWidgetProps) {\n  // Named versions of the iModel\n  const versions = useNamedVersions(props);\n  // Named version selected in dropdown\n  const [selectedVersion, setSelectedVersion] = useState<Version | undefined>();\n\n  // Callback for when clicking the \'Visualize Changed Elements\' button\n  const onVisualizeChangedElements = useCallback(async () => {\n    // We will implement this later in the tutorial\n  }, []);\n\n  // Callback for when clicking the \'Enable Change Tracking\' button\n  const onEnableTracking = useCallback(async () => {\n    // We will implement this later in the tutorial\n  }, []);\n\n  const selectOptions = [];\n  if (versions) {\n    for (const version of versions) {\n      selectOptions.push({\n        value: version,\n        label: version.name ?? "Unknown Named Version"\n      });\n    }\n  }\n\n  // On react select change set the new selected version\n  const onReactSelectChange = (option: { value: Version | undefined, label: string } | null) => {\n    setSelectedVersion(option?.value);\n  };\n\n  return (\n    <div className="widget-container">\n      <div className="widget-label">Select Named Version:</div>\n      <Select\n        value={{ value: selectedVersion, label: selectedVersion?.name ?? "" }}\n        options={selectOptions}\n        onChange={onReactSelectChange} />\n      <Button className={"widget-button"} onClick={onVisualizeChangedElements}>\n        Visualize Changed Elements\n      </Button>\n      <Button className={"widget-button"} onClick={onEnableTracking}>\n        Enable Change Tracking\n      </Button>\n    </div>\n  );\n}',mdxType:"CodeBlock"}),(0,r.kt)(g,{mdxType:"Title"},"SCSS for the UI Component"),(0,r.kt)(w,{language:"scss",code:".widget-container {\n  margin: 8px;\n}\n\n.widget-label {\n  color: white;\n  font-size: 14px;\n}\n\n.widget-button {\n  width: 100%;\n}",mdxType:"CodeBlock"})],mdxType:"TutorialSection"},(0,r.kt)("h3",{id:"31-creating-the-widget"},"3.1 Creating the widget"),(0,r.kt)("p",null,"After cloning the ",(0,r.kt)("inlineCode",{parentName:"p"},"main")," branch of the repository, create a new .tsx file and call it ",(0,r.kt)("inlineCode",{parentName:"p"},"ChangedElementsWidget.tsx"),". We are going to write a react hook that will allow us to query the named versions of the iModel, so that we can populate the dropdown list to select our version to compare against."),(0,r.kt)("p",null,"The named versions object also contains the Id of the changesets, which we will use later on to do the API calls."),(0,r.kt)("p",null,"Now that we have a working react hook for that purpose, we can write our widget component. The widget will have a label, a react select dropdown and two buttons. We will write the button\u2019s onClick handlers later on in the tutorial, so we will leave them empty for now."),(0,r.kt)("p",null,"To stylize the UI component a little bit, create a ",(0,r.kt)("inlineCode",{parentName:"p"},"ChangedElementsWidget.scss")," file and add the styles shown in the code snippet."),(0,r.kt)("p",null,"We can now proceed to add the widget to the viewer application.")),(0,r.kt)(c,{subSection:!0,actions:[(0,r.kt)(g,{mdxType:"Title"},"Create a UI Items Provider"),(0,r.kt)(w,{language:"typescript",code:"import {\n  AbstractWidgetProps,\n  StagePanelLocation,\n  StagePanelSection,\n  UiItemsProvider,\n} from '@bentley/ui-abstract';\nimport { UiFramework } from '@bentley/ui-framework';\nimport * as React from 'react';\nimport { ChangedElementsWidget } from './ChangedElementsWidget';\n\nexport class ChangedElementsUiProvider implements UiItemsProvider {\n  public readonly id = 'ChangedElementsProviderId';\n  \n  public provideWidgets(\n    stageId: string,\n    stageUsage: string,\n    location: StagePanelLocation,\n    section?: StagePanelSection\n  ): ReadonlyArray<AbstractWidgetProps> {\n\n    const widgets: AbstractWidgetProps[] = [];\n    if (\n      location === StagePanelLocation.Right &&\n      section === StagePanelSection.Start\n    ) {\n      const changedElementsWidget: AbstractWidgetProps = {\n        id: 'ChangedElementsWidget',\n        label: 'Changed Elements',\n        getWidgetContent() {\n          return (\n            <ChangedElementsWidget iModel={UiFramework.getIModelConnection()} />\n          );\n        },\n      };\n\n      widgets.push(changedElementsWidget);\n    }\n\n    return widgets;\n  }\n}",mdxType:"CodeBlock"}),(0,r.kt)(g,{mdxType:"Title"},"Import the ChangedElementsUiProvider in App.tsx"),(0,r.kt)(w,{language:"typescript",code:'import { ChangedElementsUiProvider } from "./ChangedElementsUiProvider";',mdxType:"CodeBlock"}),(0,r.kt)(g,{mdxType:"Title"},"Add the UI Items Provider to the viewer in App.tsx"),(0,r.kt)(w,{language:"typescript",code:"<Viewer\n  contextId={contextId}\n  iModelId={iModelId}\n  authConfig={{ config: authConfig }}\n  onIModelAppInit={onIModelAppInit}\n  backend={{ buddiRegion: 103 }}\n  uiProviders={[new ChangedElementsUiProvider()]}\n/>",mdxType:"CodeBlock"})],mdxType:"TutorialSection"},(0,r.kt)("h3",{id:"32-adding-the-widget-to-the-application"},"3.2 Adding the widget to the application"),(0,r.kt)("p",null,"Now that we have the component ready, we need to create a ",(0,r.kt)("a",{parentName:"p",href:"https://www.itwinjs.org/learning/ui/abstract/uiitemsprovider/"},"UiItemsProvider")," that will feed the our widget to the viewer. Create a new file ",(0,r.kt)("inlineCode",{parentName:"p"},"ChangedElementsUiProvider.tsx")," to put the code in. Then, import the ",(0,r.kt)("inlineCode",{parentName:"p"},"ChangedElementsUiProvider")," in our ",(0,r.kt)("inlineCode",{parentName:"p"},"App.tsx")," file, and add the provider to the ",(0,r.kt)("inlineCode",{parentName:"p"},"uiProviders")," array prop of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Viewer")," react component."),(0,r.kt)(y,{type:"informational",mdxType:"Alert"},"If you want a more in-depth explanation on the usage of the provider, see"," ",(0,r.kt)("a",{style:{textDecoration:"underline"},href:"/tutorials/itwin-viewer-hello-world"},"iTwin Viewer Hello World tutorial"),"."),(0,r.kt)("p",null,"Then, we must pass the provider to the viewer\u2019s react component, and it should now show in right panel like so:"),(0,r.kt)("div",{style:{marginTop:"16px",marginBottom:"16px"}},(0,r.kt)("img",{src:"../../images/changed-elements-widget.png",style:{margin:"auto"}})),(0,r.kt)("p",null,"If you want to verify that you have added the code in the right place, you can check the final results for ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/iTwin/changed-elements-tutorial/blob/main/src/App.tsx"},"App.tsx"),", ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/iTwin/changed-elements-tutorial/blob/main/src/ChangedElementsWidget.tsx"},"ChangedElementsWidget.tsx")," and ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/iTwin/changed-elements-tutorial/blob/main/src/ChangedElementsUiProvider.tsx"},"ChangedElementsUiProvider.tsx"),". Keep in mind that the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/iTwin/changed-elements-tutorial/blob/main/src/ChangedElementsWidget.tsx"},"ChangedElementsWidget.tsx")," code in the repository is already in its final state, containing button handlers that we will be adding later on in this tutorial.")),(0,r.kt)(c,{subSection:!0,actions:[(0,r.kt)(g,{mdxType:"Title"},"Changed Elements Client"),(0,r.kt)(w,{language:"typescript",code:'import { ChangedElements } from "@bentley/imodeljs-common";\nimport { IModelConnection } from "@bentley/imodeljs-frontend";\nimport { AccessToken, AuthorizedClientRequestContext, IncludePrefix, request, RequestOptions } from "@bentley/itwin-client";\nimport { AuthorizationClient } from "./AuthorizationClient";\n\n/**\n * Class for using the Changed Elements API\n */\nexport class ChangedElementsClient {\n  /**\n   * Get base URL for changed elements API\n   * @returns URL for changed elements API\n   */\n  public getUrl() {\n    return "https://api.bentley.com/changedelements";\n  }\n\n  /**\n   * Function to form the URL for the comparison operation of changed elements API\n   * @param iModelId iModel Id to query for\n   * @param projectId Project Id of the iModel\n   * @param startChangesetId Start changeset for comparison data\n   * @param endChangesetId End changeset for comparison data\n   * @returns Url for querying changed elements from the changed elements API\n   */\n  public getComparisonOperationUrl(\n    iModelId: string,\n    projectId: string,\n    startChangesetId: string,\n    endChangesetId: string\n  ) {\n    return this.getUrl() +\n      "/comparison?iModelId=" + iModelId +\n      "&projectId=" + projectId +\n      "&startChangesetId=" + startChangesetId +\n      "&endChangesetId=" + endChangesetId;\n  }\n\n  /**\n   * Function to form the URL for the enable change tracking operation of changed elements API\n   * @returns Url for enabling/disabling change tracking\n   */\n  public getEnableChangeTrackingUrl() {\n    return this.getUrl() + "/tracking"\n  }\n\n  /**\n   * Tries to get an access token from the authorization client\n   * Should work if your .env is setup properly and your application\'s client\n   * is setup correctly\n   * @returns AccessToken or undefined\n   */\n  private async getAccessToken(): Promise<AccessToken | undefined> {\n    try {\n      return await AuthorizationClient.apimClient.getAccessToken();\n    } catch(e) {\n      console.error(e);\n      return undefined;\n    }\n  }\n\n  /**\n   * Headers for requests\n   * @param requestContext \n   * @returns \n   */\n  public getHeaderOptions(accessToken: AccessToken) {\n    return {\n      Authorization: accessToken.toTokenString(IncludePrefix.Yes),\n    }\n  }\n\n  /**\n   * Gets the changed elements between two changesets using the changed elements API\n   * This results in a GET request to the comparison endpoint\n   * @param iModel iModel to test\n   * @param startChangesetId Start changeset Id\n   * @param endChangesetId End changeset Id\n   * @returns ChangedElements object or undefined\n   */\n  public async getComparison(\n    iModel: IModelConnection,\n    startChangesetId: string,\n    endChangesetId: string\n  ): Promise<ChangedElements | undefined> {\n    const accessToken = await this.getAccessToken();\n    if (accessToken === undefined) {\n      throw new Error("Could not get access token");\n    }\n    // Create a request context\n    const requestContext = new AuthorizedClientRequestContext(accessToken);\n    // Parse out iModel Id and Project Id\n    const iModelId = iModel.iModelId;\n    const projectId = iModel.contextId;\n    // Ensure they are properly defined\n    if (iModelId === undefined || projectId === undefined) {\n      throw new Error("IModel is not properly defined");\n    }\n\n    // Get the request URL for the comparison operation\n    const url: string = this.getComparisonOperationUrl(iModelId, projectId, startChangesetId, endChangesetId);\n    // Options for the request\n    const options: RequestOptions = {\n      method: "GET",\n      headers: this.getHeaderOptions(accessToken)\n    };\n    try {\n      // Execute the request\n      const response = await request(requestContext, url, options);\n      // Ensure we got a proper response\n      if (response.status === 200 && response.body?.changedElements !== undefined) {\n        // If so, cast the changedElements object of the body as a ChangedElements type\n        return response.body.changedElements as ChangedElements;\n      }\n      // Something went wrong, log it to console\n      console.error("Could not get changed elements. Status: " + response.status + ". Body: " + response.body);\n    } catch (e) {\n      console.error("Error obtaining changed elements: " + e);\n    }\n\n    // We did not get a proper response, return undefined\n    return undefined;\n  }\n\n  /**\n   * Enable or disable change tracking for an iModel\n   * This will cause the iModel to be monitored for named versions\n   * Whenever a named version gets created, the changed elements API will process the changesets\n   * so that a comparison operation can be made against the new named versions\n   * @param iModel IModel to track change for\n   * @param value true for enabling, false for disabling\n   * @returns true if successful, false if failed\n   */\n  public async enableChangeTracking(\n    iModel: IModelConnection,\n    value: boolean,\n  ): Promise<boolean> {\n    const accessToken = await this.getAccessToken();\n    if (accessToken === undefined) {\n      throw new Error("Could not get access token");\n    }\n    // Create a request context\n    const requestContext = new AuthorizedClientRequestContext(accessToken);\n    // Parse out iModel Id and Project Id\n    const iModelId = iModel.iModelId;\n    const projectId = iModel.contextId;\n    // Ensure they are properly defined\n    if (iModelId === undefined || projectId === undefined) {\n      throw new Error("IModel is not properly defined");\n    }\n\n    // Get the request URL for the comparison operation\n    const url: string = this.getEnableChangeTrackingUrl();\n    // Options for the request\n    const options: RequestOptions = {\n      method: "PUT",\n      headers: this.getHeaderOptions(accessToken),\n      body: {\n        enable: value,\n        iModelId,\n        projectId,\n      }\n    };\n    try {\n      // Execute the request\n      const response = await request(requestContext, url, options);\n      // Ensure we get a proper response\n      if (response.status === 202) {\n        return true;\n      }\n      // Something went wrong, log it to console\n      console.error("Could not enable change tracking. Status: " + response.status + ". Body: " + response.body);\n    } catch (e) {\n      console.error("Error change tracking: " + e);\n    }\n\n    // We did not get a proper response, return undefined\n    return false;\n  }\n}',mdxType:"CodeBlock"})],mdxType:"TutorialSection"},(0,r.kt)("h3",{id:"33-writing-a-client-for-the-api"},"3.3 Writing a client for the API"),(0,r.kt)("p",null,"To use the API in our viewer, we will need to create a client class that interfaces with the API and gives us the proper results."),(0,r.kt)("p",null,"Create a new file called ",(0,r.kt)("inlineCode",{parentName:"p"},"ChangedElementsClient.ts")," and create a class like shown in the code snippet. We are first going to write functions to create the correct URLs for our operations based on some input parameters, like our iModel\u2019s Id and changeset Ids."),(0,r.kt)("p",null,"Now that we have the scaffolding for the client class, let\u2019s add functions for calling the API for each operation."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"getComparison")," function will use the ",(0,r.kt)("a",{parentName:"p",href:"/apis/changed-elements/operations/get-comparison/"},"Get Comparison")," endpoint to get the ",(0,r.kt)("a",{parentName:"p",href:"https://www.itwinjs.org/reference/imodeljs-common/entities/changedelements/"},"ChangedElements")," that were found between the given changesets, for a given iModel."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"enableChangeTracking")," function will use the ",(0,r.kt)("a",{parentName:"p",href:"/apis/changed-elements/operations/enable-change-tracking/"},"Enable Change Tracking")," endpoint to enable or disable tracking for an iModel."),(0,r.kt)("p",null,"Both operations require an authorization token. The repository comes with a simple ",(0,r.kt)("inlineCode",{parentName:"p"},"AuthorizationClient")," class that will get the necessary tokens as long as your ",(0,r.kt)("inlineCode",{parentName:"p"},".env")," file is properly setup as explained in the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/iTwin/changed-elements-tutorial/blob/main/README.md"},"README")," of the repo"),(0,r.kt)("p",null,"Here\u2019s what the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/iTwin/changed-elements-tutorial/blob/main/src/ChangedElementsClient.ts"},"ChangedElementsClient.ts")," file should look like when you are done with this section.")),(0,r.kt)(c,{subSection:!0,actions:[(0,r.kt)(g,{mdxType:"Title"},"Import the ChangedElementsClient class in ChangedElementsWidget"),(0,r.kt)(w,{language:"typescript",code:'import { ChangedElementsClient } from "./ChangedElementsClient"; ',mdxType:"CodeBlock"}),(0,r.kt)(g,{mdxType:"Title"},"Enable Change Tracking Button Handler"),(0,r.kt)(w,{language:"typescript",code:"// Callback for when clicking the 'Enable Change Tracking' button\nconst onEnableTracking = useCallback(async () => {\n  const iModel = props.iModel;\n  // Ensure our iModel is defined\n  if (iModel) {\n    // Create a changed elements client object\n    const client = new ChangedElementsClient();\n    // Enable change tracking for the iModel\n    await client.enableChangeTracking(iModel, true);\n  }\n}, [props.iModel]);\n",mdxType:"CodeBlock"}),(0,r.kt)(g,{mdxType:"Title"},"Visualize Changed Elements Button Handler"),(0,r.kt)(w,{language:"typescript",code:'// Callback for when clicking the \'Visualize Changed Elements\' button\nconst onVisualizeChangedElements = useCallback(async () => {\n  const iModel = props.iModel;\n  if (iModel === undefined || iModel.changeSetId === undefined) {\n    console.error("iModel is not valid");\n    return;\n  }\n  if (selectedVersion?.changeSetId === undefined) {\n    console.error("Selected version is not defined");\n    return;\n  }\n  const client = new ChangedElementsClient();\n  const endChangesetId = iModel.changeSetId;\n  const startChangesetId = selectedVersion?.changeSetId;\n  const changedElements = await client.getComparison(\n    iModel,\n    startChangesetId,\n    endChangesetId\n  );\n  // Log the results to console to inspect them\n  console.log(changedElements);\n  const viewport = IModelApp.viewManager.selectedView;\n  if (changedElements && viewport) {\n    // Emphasize the changed elements in the view\n    EmphasizeElements.getOrCreate(viewport).emphasizeElements(\n      changedElements.elements,\n      viewport\n    );\n  }\n}, [selectedVersion, props.iModel]);',mdxType:"CodeBlock"})],mdxType:"TutorialSection"},(0,r.kt)("h3",{id:"34-using-the-client"},"3.4 Using the client"),(0,r.kt)("p",null,"Now, we must implement the onClick handlers of the widget buttons so that they use the client and call the necessary API endpoints. First, ensure you import the ",(0,r.kt)("inlineCode",{parentName:"p"},"ChangedElementsClient")," to be used in the ",(0,r.kt)("inlineCode",{parentName:"p"},"ChangedElementsWidget.tsx")," file."),(0,r.kt)("p",null,"For enabling change tracking, all we need to do is use the client\u2019s ",(0,r.kt)("inlineCode",{parentName:"p"},"enableChangeTracking")," method we wrote earlier. Paste the code in the ",(0,r.kt)("inlineCode",{parentName:"p"},"onEnableTracking")," callback that we left blank earlier in ",(0,r.kt)("a",{parentName:"p",href:"#31-creating-the-widget"},"Section 3.1"),". For this to work, we just need to pass the ",(0,r.kt)("inlineCode",{parentName:"p"},"iModel")," object and ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," to the client\u2019s function. If you have not enabled change tracking on your iModel yet, do so now. Keep in mind that as mentioned in section 2.1.3, processing may take a while, so take a break and get some coffee to ensure that the API processes your iModel."),(0,r.kt)("p",null,"For visualizing changed elements, we are going to need to use the client\u2019s ",(0,r.kt)("inlineCode",{parentName:"p"},"getComparison")," method. This requires us to pass the ",(0,r.kt)("inlineCode",{parentName:"p"},"iModel")," object, ",(0,r.kt)("inlineCode",{parentName:"p"},"startChangesetId")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"endChangesetId"),". We can obtain the ",(0,r.kt)("inlineCode",{parentName:"p"},"iModel")," from the passed props of the widget. The ",(0,r.kt)("inlineCode",{parentName:"p"},"endChangesetId")," we can obtain by looking at the iModel\u2019s current changeset. For ",(0,r.kt)("inlineCode",{parentName:"p"},"startChangesetId"),", we need to use the ",(0,r.kt)("inlineCode",{parentName:"p"},"selectedVersion")," variable we setup in the widget that should contain the changeset Id of the named version that got selected by the user. Paste the code in the ",(0,r.kt)("inlineCode",{parentName:"p"},"onVisualizeChangedElements")," callback that we left blank earlier in ",(0,r.kt)("a",{parentName:"p",href:"#31-creating-the-widget"},"Section 3.1"),". If you get a ",(0,r.kt)("inlineCode",{parentName:"p"},"404")," response from the ",(0,r.kt)("a",{parentName:"p",href:"/apis/changed-elements/operations/get-comparison/"},"Get Comparison")," operation, it means the API has not yet processed your iModel, and you must wait."),(0,r.kt)("p",null,"If authorization has been properly setup, you should obtain results from the API. To display the results in the viewport, let\u2019s emphasize the elements that have changed on the screen. We can use the ",(0,r.kt)("a",{parentName:"p",href:"https://www.itwinjs.org/reference/imodeljs-frontend/rendering/emphasizeelements/"},"EmphasizeElements")," class, which is a ",(0,r.kt)("a",{parentName:"p",href:"https://www.itwinjs.org/reference/imodeljs-frontend/views/featureoverrideprovider/"},"FeatureOverrideProvider")," that will highlight the elements on the viewport."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"changedElements.elements")," is an array that contains the element Ids of all elements that have changed in the iModel between the changesets that we are looking at. Here\u2019s more information about the ",(0,r.kt)("a",{parentName:"p",href:"https://www.itwinjs.org/reference/imodeljs-common/entities/changedelements/"},"ChangedElements")," result."),(0,r.kt)("p",null,"Here\u2019s what the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/iTwin/changed-elements-tutorial/blob/main/src/ChangedElementsWidget.tsx"},"ChangedElementsWidget.tsx")," file should look like when you are done with this section.")),(0,r.kt)(c,{subSection:!0,actions:[(0,r.kt)(g,{mdxType:"Title"},"Changed Elements Feature Override Provider"),(0,r.kt)(w,{language:"typescript",code:'import { DbOpcode, Id64String } from "@bentley/bentleyjs-core";\nimport { ChangedElements, FeatureAppearance } from "@bentley/imodeljs-common";\nimport { FeatureOverrideProvider, FeatureSymbology, Viewport } from "@bentley/imodeljs-frontend";\n\n/**\n * Feature Override Provider to visualize changed elements and colorize them\n * in the viewport\n */\nexport class ChangedElementsFeatureOverrides implements FeatureOverrideProvider {\n  // Array of inserted element Ids\n  private _insertedElements: Id64String[] = [];\n  // Array of updated element Ids\n  private _updatedElements: Id64String[] = [];\n\n  /**\n   * Constructor\n   * @param changedElements Changed Elements to visualize\n   */\n  public constructor(changedElements: ChangedElements) {\n    // Go over all changed elements array, all arrays are guaranteed to have same size\n    for (let i = 0; i < changedElements.elements.length; ++i) {\n      // Element Id of the changed element\n      const elementId: Id64String = changedElements.elements[i];\n      // Operation code of the changed element\n      const opcode: DbOpcode = changedElements.opcodes[i];\n      // Add the element Id to the proper list\n      switch (opcode) {\n        case DbOpcode.Delete:\n          // Deleted elements do not exist in the current version of the iModel\n          // Displaying non-iModel elements in the same view is out of scope for this tutorial\n          break;\n        case DbOpcode.Update:\n          this._updatedElements.push(elementId);\n          break;\n        case DbOpcode.Insert:\n          this._insertedElements.push(elementId);\n          break;\n      }\n    }\n  }\n\n  /**\n   * Adds the colorization and emphasis of the elements we care about\n   * @param overrides Overrides to be updated with our changed elements\n   * @param viewport Viewport we are overriding features on\n   */\n  public addFeatureOverrides(overrides: FeatureSymbology.Overrides, viewport: Viewport): void {\n    // Create a default appearance for non-changed elements, set it to transparent light gray\n    const defaultAppearance = FeatureAppearance.fromJSON({\n      rgb: {r: 200, g: 200, b: 200},\n      transparency: 0.9,\n      // Make unchanged elements non-locatable\n      // This is to allow selecting changed elements that are behind unchanged elements in the view\n      nonLocatable: true,\n    });\n    // Override the default coloring for all other elements\n    overrides.setDefaultOverrides(defaultAppearance);\n\n    // Create an appearance with the color green for inserted elements and emphasize them\n    const insertedAppearance = FeatureAppearance.fromJSON({\n      rgb: {r: 0, g: 255, b: 0},\n      emphasized: true,\n    });\n    // Override the inserted elements with the appearance\n    this._insertedElements.forEach((elementId: string) => {\n      overrides.overrideElement(elementId, insertedAppearance);\n    });\n\n    // Create an appearance with the color blue for updated elements\n    const updatedAppearance = FeatureAppearance.fromJSON({\n      rgb: {r: 0, g: 0, b: 255},\n      emphasized: true\n    });\n    // Override the updated elements with the appearance\n    this._updatedElements.forEach((elementId: string) => {\n      overrides.overrideElement(elementId, updatedAppearance);\n    });\n  }\n}',mdxType:"CodeBlock"}),(0,r.kt)(g,{mdxType:"Title"},"Updated Visualize Changed Elements Button Callback"),(0,r.kt)(w,{language:"typescript",code:'// Updated callback for when clicking the \'Visualize Changed Elements\' button\nconst onVisualizeChangedElements = useCallback(async () => {\n  const iModel = props.iModel;\n  if (iModel === undefined || iModel.changeSetId === undefined) {\n    console.error("iModel is not valid");\n    return;\n  }\n  if (selectedVersion?.changeSetId === undefined) {\n    console.error("Selected version is not defined");\n    return;\n  }\n  const client = new ChangedElementsClient();\n  const endChangesetId = iModel.changeSetId;\n  const startChangesetId = selectedVersion?.changeSetId;\n  const changedElements = await client.getComparison(\n    iModel,\n    startChangesetId,\n    endChangesetId\n  );\n  // Log the results to console to inspect them\n  console.log(changedElements);\n\n  const viewport = IModelApp.viewManager.selectedView;\n  if (changedElements && viewport) {\n    // Ensure we are not currently visualizing changed elements\n    const oldProvider = viewport.findFeatureOverrideProviderOfType(ChangedElementsFeatureOverrides);\n    if (oldProvider) {\n      // If we are, drop the override provider so that we start with a clean viewport\n      viewport.dropFeatureOverrideProvider(oldProvider);\n    }\n    // Create our feature override provider object\n    const overrideProvider = new ChangedElementsFeatureOverrides(changedElements);\n    // Add it to the viewport\n    viewport.addFeatureOverrideProvider(overrideProvider);\n\n    // Store changed elements in component\n    setChangedElements(changedElements);\n  }\n}, [selectedVersion]);',mdxType:"CodeBlock"})],mdxType:"TutorialSection"},(0,r.kt)("h3",{id:"35-enhancing-the-change-visualization"},"3.5 Enhancing the change visualization"),(0,r.kt)("p",null,"By now, you should have changed elements being emphasized in your view, but it would be better if we colorize them by their operation codes, see ",(0,r.kt)("a",{parentName:"p",href:"https://www.itwinjs.org/reference/bentleyjs-core/besqlite/dbopcode/"},"DbOpcode"),"."),(0,r.kt)("p",null,"To be able to colorize the elements, we will implement our own ",(0,r.kt)("a",{parentName:"p",href:"https://www.itwinjs.org/reference/imodeljs-frontend/views/featureoverrideprovider"},"FeatureOverrideProvider"),". Create a new file ",(0,r.kt)("inlineCode",{parentName:"p"},"ChangedElementsFeatureOverrides.ts")," and follow the code snippet to the right."),(0,r.kt)("p",null,"The provider\u2019s constructor finds which elements are inserted or updated based on their ",(0,r.kt)("a",{parentName:"p",href:"https://www.itwinjs.org/reference/bentleyjs-core/besqlite/dbopcode/"},"DbOpcode"),". Then, it implements the ",(0,r.kt)("inlineCode",{parentName:"p"},"addFeatureOverrides")," function that will colorize inserted elements as green, updated elements as blue and make everything else transparent gray."),(0,r.kt)(y,{type:"informational",mdxType:"Alert"},"Displaying deleted elements is not as straightforward because the deleted elements are not present in the current iModel that we are displaying in the viewport. This can be done by implementing a"," ",(0,r.kt)("a",{style:{textDecoration:"underline"},href:"https://www.itwinjs.org/reference/imodeljs-frontend/views/tiledgraphicsprovider/"},"TiledGraphicsProvider"),", but this is out of the scope for this tutorial."),(0,r.kt)("p",null,"Now that we have a feature override provider that will colorize our elements properly, let\u2019s use it in our ",(0,r.kt)("inlineCode",{parentName:"p"},"onVisualizeChangedElements")," button callback. Import the class in ",(0,r.kt)("inlineCode",{parentName:"p"},"ChangedElementsWidget.tsx"),"."),(0,r.kt)("p",null,"Before adding a provider to the viewport, t\u2019s important to drop any feature override providers from the viewport before we add one to ensure we start with a clean viewport each time."),(0,r.kt)("p",null,"You should now be able to see the elements colorized, showing inserted elements as green and updated elements as blue whenever we click the visualize button:"),(0,r.kt)("div",{style:{marginTop:"16px",marginBottom:"16px"}},(0,r.kt)("img",{src:"../../images/changed-elements-colorized.png",style:{margin:"auto"}})),(0,r.kt)("p",null,"Here\u2019s what the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/iTwin/changed-elements-tutorial/blob/main/src/ChangedElemensFeatureOverrides.ts"},"ChangedElementsFeatureOverrides.ts")," file should look like when you are done with this section.")),(0,r.kt)(c,{subSection:!0,mdxType:"TutorialSection"},(0,r.kt)("h3",{id:"36-about-changed-properties"},"3.6 About changed properties"),(0,r.kt)("p",null,"We will cover working with properties from Changed Elements API in a different tutorial, but here\u2019s an overview of what\u2019s provided in the API:"),(0,r.kt)("p",null,"The API returns a ",(0,r.kt)("inlineCode",{parentName:"p"},"properties")," array that contains the ",(0,r.kt)("inlineCode",{parentName:"p"},"EC Property Access Strings")," of any properties that had changes between the two versions being queried. The ",(0,r.kt)("inlineCode",{parentName:"p"},"properties")," array is 2-dimensional, the first index corresponds to the element you are looking at, the second index will allow you to iterate through all properties that changed in the element."),(0,r.kt)("p",null,"As explained in the ",(0,r.kt)("a",{parentName:"p",href:"#21-enabling-change-tracking"},"Enabling Change Tracking Section"),", the properties of an element may not live in the element itself, so we can\u2019t simply query for its value using ECSQL, the element Id and the property access string."),(0,r.kt)("p",null,"To properly inspect an elements properties, including properties that do not exist on the element, we need to use ",(0,r.kt)("a",{parentName:"p",href:"https://www.itwinjs.org/learning/presentation/"},"iTwin.js Presentation Library"),", which is out of scope for this tutorial."),(0,r.kt)("p",null,"The change data also contains the ",(0,r.kt)("inlineCode",{parentName:"p"},"newChecksums")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"oldChecksums")," arrays. Each property of an element will have a matching new and old checksum. These arrays are useful to quickly check if the property value indeed has changed, or if it has flipped back and forth to the same value between versions.")),(0,r.kt)(c,{mdxType:"TutorialSection"},(0,r.kt)("h2",{id:"4-making-sense-of-changed-elements-data"},"4. Making sense of Changed Elements data"),(0,r.kt)("p",null,"The returned data is a JSON object that contains arrays of data. Each of these arrays are of the same length. This length is the number of changed elements that were found during processing.")),(0,r.kt)(c,{subSection:!0,mdxType:"TutorialSection"},(0,r.kt)("h3",{id:"41-changed-elements-json"},"4.1 Changed Elements JSON"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://www.itwinjs.org/reference/imodeljs-common/entities/changedelements/"},"ChangedElements")," class is defined in the @bentley/imodeljs-common package."),(0,r.kt)("p",null,"As mentioned before, this interface contains different arrays. Let\u2019s go over each of the arrays and what they are:"),(0,r.kt)("h5",{id:"elements"},(0,r.kt)("strong",{parentName:"h5"},"elements")),(0,r.kt)("p",null,"Contains the element Ids of the changed elements. This is useful if you want to query the iModel for more information about the element."),(0,r.kt)("h5",{id:"classids"},(0,r.kt)("strong",{parentName:"h5"},"classIds")),(0,r.kt)("p",null,"Contains the ECClass Ids of the changed elements. This is useful if you want to access specific properties of the element that are in its ECClass."),(0,r.kt)("h5",{id:"opcodes"},(0,r.kt)("strong",{parentName:"h5"},"opcodes")),(0,r.kt)("p",null,"Contains the operation codes that tells us if the element was inserted, updated or deleted in the change. See ",(0,r.kt)("a",{parentName:"p",href:"https://www.itwinjs.org/reference/bentleyjs-core/besqlite/dbopcode/?term=dbopcode"},"DbOpcode")),(0,r.kt)("h5",{id:"type"},(0,r.kt)("strong",{parentName:"h5"},"type")),(0,r.kt)("p",null,"Contains the type of change that occurred to the element. This number is a bitflag, and can be used to know whether the element had property changes, geometric changes, placement changes, indirect changes and/or hidden property changes."),(0,r.kt)("h5",{id:"modelids"},(0,r.kt)("strong",{parentName:"h5"},"modelIds")),(0,r.kt)("p",null,"Contains the model Ids of the changed elements. This is useful for visualization purposes, like ensuring the model the changed element resides in is displayed in the viewport."),(0,r.kt)("h5",{id:"properties"},(0,r.kt)("strong",{parentName:"h5"},"properties")),(0,r.kt)("p",null,"Contains the property accessor string names of changed properties an element may have. This property accessor string can be used in conjunction with the element\u2019s class Id to obtain the property value."),(0,r.kt)("h5",{id:"oldchecksums"},(0,r.kt)("strong",{parentName:"h5"},"oldChecksums")),(0,r.kt)("p",null,"Contains the old checksum for the property value of the index that matches the property array. This is useful to determine using newChecksums array, whether the property value has indeed changed in the before and after states of the iModel. This is useful because there are cases in which a property may be flipped back and forth, and you may still want to know it was touched, but you can determine whether the change is valuable using a simple checksum comparison."),(0,r.kt)("h5",{id:"newchecksums"},(0,r.kt)("strong",{parentName:"h5"},"newChecksums")),(0,r.kt)("p",null,"Contains the new checksum for the property value of the index that matches the property array"),(0,r.kt)("h5",{id:"parentids"},(0,r.kt)("strong",{parentName:"h5"},"parentIds")),(0,r.kt)("p",null,"Contains the parent Id of the element. If the element does not have a parent, this id will be \u201c0\u201d"),(0,r.kt)("h5",{id:"parentclassids"},(0,r.kt)("strong",{parentName:"h5"},"parentClassIds")),(0,r.kt)("p",null,"Contains the ECClass Id of the parent of the element. If the element does not have a parent, this id will be \u201c0\u201d")),(0,r.kt)(c,{mdxType:"TutorialSection"},(0,r.kt)("h2",{id:"conclusion"},"Conclusion"),(0,r.kt)("p",null,"Congratulations on completing this tutorial, at this point you should have been able to visualize change using the API! In conclusion, the Changed Elements API can help you understand what elements have changed in your iModel and how they have changed between the given changesets. You could use this API to generate reports, visualize change using an iTwin.js application like we did in this tutorial, or review properties that have changed on the elements that you find relevant in your iModel.")),(0,r.kt)(C,{mdxType:"ContinueLearningSection"},(0,r.kt)("h2",{id:"more-resources-that-you-may-like"},"More resources that you may like"),(0,r.kt)(v,{mdxType:"TileList"},(0,r.kt)(T,{title:"Create React App",href:"https://create-react-app.dev",description:"Set up a modern web app by running one command.",isExternal:!0,mdxType:"ResourceTile"}),(0,r.kt)(T,{title:"iTwin Viewer React",href:"https://www.npmjs.com/package/@itwin/web-viewer-react",description:(0,r.kt)(i.Fragment,null,"The iTwin Viewer is a configurable iTwin.js viewer that offers basic tooling and widgets out-of-the-box and can be further extended through the use of ",(0,r.kt)("a",{href:"https://github.com/imodeljs/extension-sample",target:"_blank"},"iTwin.js extensions"),". This package contains the Viewer as a React component and some additional Typescript APIs."),isExternal:!0,mdxType:"ResourceTile"}),(0,r.kt)(T,{title:"iTwin Viewer Create React App Template",href:"https://www.npmjs.com/package/@itwin/cra-template-web-viewer",description:(0,r.kt)(i.Fragment,null,"This is a template for applications that are based on the ",(0,r.kt)("a",{href:"https://github.com/iTwin/viewer/tree/master/packages/modules/web-viewer-react",target:"_blank"},"iTwin Viewer")," for ",(0,r.kt)("a",{href:"https://github.com/facebook/create-react-app",target:"_blank"},"Create React App"),"."),isExternal:!0,mdxType:"ResourceTile"}),(0,r.kt)(T,{title:"Bentley React Scripts",href:"https://www.npmjs.com/package/@bentley/react-scripts",description:"This is the iTwin.js fork of react-scripts.",isExternal:!0,mdxType:"ResourceTile"}))))}E.isMDXComponent=!0;var x=function(){return[{id:"introduction",level:2,title:"Introduction",children:[]},{id:"1-set-up-your-environment",level:2,title:"1. Set up your environment",children:[{id:"11-required-materials",level:3,title:"1.1 Required materials",children:[]},{id:"12-suggested-materials",level:3,title:"1.2 Suggested materials",children:[]}]},{id:"2-overview-of-changed-elements-api",level:2,title:"2. Overview of Changed Elements API",children:[{id:"21-enabling-change-tracking",level:3,title:"2.1 Enabling Change Tracking",children:[]},{id:"22-getting-changed-elements",level:3,title:"2.2 Getting Changed Elements",children:[]}]},{id:"3-putting-it-to-work",level:2,title:"3. Putting it to work",children:[{id:"31-creating-the-widget",level:3,title:"3.1 Creating the widget",children:[]},{id:"32-adding-the-widget-to-the-application",level:3,title:"3.2 Adding the widget to the application",children:[]},{id:"33-writing-a-client-for-the-api",level:3,title:"3.3 Writing a client for the API",children:[]},{id:"34-using-the-client",level:3,title:"3.4 Using the client",children:[]},{id:"35-enhancing-the-change-visualization",level:3,title:"3.5 Enhancing the change visualization",children:[]},{id:"36-about-changed-properties",level:3,title:"3.6 About changed properties",children:[]}]},{id:"4-making-sense-of-changed-elements-data",level:2,title:"4. Making sense of Changed Elements data",children:[{id:"41-changed-elements-json",level:3,title:"4.1 Changed Elements JSON",children:[]}]},{id:"conclusion",level:2,title:"Conclusion",children:[]},{id:"more-resources-that-you-may-like",level:2,title:"More resources that you may like",children:[]}]}}}]);