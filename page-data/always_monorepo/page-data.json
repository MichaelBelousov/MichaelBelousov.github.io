{"componentChunkName":"component---src-components-blog-page-tsx","path":"/always_monorepo/","result":{"data":{"markdownRemark":{"html":"<p>Always use a monorepo. Because otherwise the temptation to jam more stuff into one package is too strong.\nContext switches are annoying, and that may prevent you from correctly crossing package lines when thinking\nwhere to put your code. In my terrible opinion you can always extract the history out to\na separate repo later with <a href=\"https://github.com/newren/git-filter-repo\">git filter-repo</a>.</p>\n<p>Anyway, the <em>real</em> reason to use a monorepo is because in tooling environments like HTML5\nJavaScript stacks (e.g. create-react-app),\n(where monorepo jargon is especially popular) you can expose custom linter rule packages that\nbend everyone to your all-knowing will!!!!!! In a work project recently, we had some Sass theming logic\nthat I deprecated in favor of a more direct, less complicated method for achieving the same thing.\nWe all wanted a better method and had been looking for a while.\nDeprecating it was a great step, but in a large product code base, there's little value and\npossible danger in taking a long time to rewrite all of the deprecated references.\nThe ideal approach is \"progressive migration\"â€”not wasting time converting everything\nthat works fine as is, but slowly converting anything that needs maintenance, implying a\nsort of LRU chipping away at usage of the deprecated styling technique. Since we were already using\nlint-staged+husky to force linting of vcs-staged files precommit, I just added the new\ndeprecation rule and set it to error, so\nother developers could not change style files without first migrating the deprecated references.\nIt's a tad intense since it still\ndemands that you migrate any file you may make small changes to, but it ensures active files receive\nthe love of an easier theming logic so future maintenance is easier.</p>\n<p>Without a very proper naming scheme, or private package registry like we have, project-scope\npackages are a bit difficult to justify. But, if you're careful, there's a lot of value and change\nyou can bring about by reading your linters' APIs.</p>\n<p>Without a monorepo setup, I'd have had to setup a separate repository and publishing pipeline. Not\na ton of work, but for a utility of exactly project-scope it belongs in your project's source\n(vcs) context. I especially opted for this since stylelint only seems to support package-level\ncustom rules (afaik). I'm sure a module-level custom rule would have been nicer for something\nproject-only.</p>\n<p>JS Monorepos can come with their own headaches, but the scalable reusability is essential.</p>","frontmatter":{"title":"Always use a Monorepo","path":"/blog/always-monorepo","date":"February 15, 2020"}}},"pageContext":{"slug":"/always_monorepo/"}}}