{"componentChunkName":"component---src-pages-blog-tsx","path":"/blog/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<p>I've been working on a human eye recently. It's not done, but I think I'll put up a description (or even a youtube tutorial?)\non how to make a fully procedural eye once I'm done. Or at least a vanity post of how many nodes I used.\nIt contains <em>no</em> images/textures. Everything is generated using math and noise\nfunctions, in particular Blender's standard Cycle's Perlin noise implementation, Musgrave, and Voronoi.</p>\n<div style=\"text-align:center\">\n  <img style=\"width:50%\" alt=\"you seem to not be able to see the image\" src=\"/images/the_eye.png\" />\n</div>\n<p>You can tell it's not done based on the iris color, and the fact that I haven't rendered it with the clear gel layer that the\neye typically has around it, which would cause some much needed refraction. Also this version doesn't tone down the veins as\nmuch as needed.  Still, I'm pretty happy with some of the results so far so I figured I'd put it out here.</p>","frontmatter":{"date":"December 19, 2019","path":"/blog/eye-progress","title":"Eye Progress"}}},{"node":{"html":"<p>I needed to do a top-down draft, a design of something I would be 3D-modeling later, and so I opened up\nmy 2D drawing toolkit, Krita. I bumped the resolution to\n5000x5000 pixels, and had to think deeply about it.</p>\n<p>The lack of dynamic resolution in such raster based D image manipulation programs is saddening. Especially\nin my drafting process. It's inconvenient to have to worry about blurry details when zooming in too far, or slow stroke\nrendering/committing when zooming out too much. So, since I already use Blender for practically everything else and\nwas enjoying the quality of life improvements in Blender 2.8 recently, I decided to check out its new 2D (Grease Pencil) tools for kicks.\nLo and behold, the lagless, vector-based, infinite resolution, hassle-free zoom, layered, materialed, simple, beautiful 2D workspace of my\ndreams was before me. Gone are the drafting days of drawing arrows to various scene elements to elaborate on them.\nJust zoom into them! You can just zoom infinitely and write inside them. The brushes are clean, and\ncustomizable. Erasing is instant (use point-erase), and rendering is lagless. And since you're not\ndealing with raster, there are <em>no</em> complex selections to perform. You can select strokes independently,\nselect their points, move things, scale things, and it takes no time at all. You can <em>sculpt</em> your points,\nadding or reducing thickness of lines, moving them, adding some fuzziness, simplifying them, and more. It's not\njust good for drafting, but all drawing comes naturally to it. And you can even extend it to 3D! Draw in 3D,\nstart modeling in 3D. Draw on your 3D models to concept some greebling if your artstyle demands it!\nIt has never felt so easy to me. Blender has always been good at what it does,\nbut it has never felt so exceptionally designed until now. Whether you're designing interfaces or levels, doing\n3D graphics work, doing 2D work, or any animation, definitely get into Blender 2.8 and start a new 2D drawing\nproject. It just works!</p>","frontmatter":{"date":"July 13, 2019","path":"/blog/blender-2.8-grease-pencil-is-awesome","title":"Blender 2.8 Grease Pencil Is Awesome"}}},{"node":{"html":"<p>The one nagging gap in my homework development stack early on\nwas an itch for\nprogrammability, that trait which Excel is alleged to have.\nBut I have a gripe with Excel. It's like Scratch for adults,\nA psuedoscripting language for the uninitiated and unlearned.\nPersonally, I've always kicked up a Python interpreter any\ntime I needed a calculation, and I quickly began depending on\nPython+scipy for more intense derivations and data routines. I scratched\nup a utility module for producing LaT<sub>E</sub>X tables and pgfplots graphics\nfrom various data formats, and used it frequently with minimal\ncopy and paste glue (thank you Cygwin's\n<code>/dev/clipboard</code>).</p>\n<p>But larger projects begged for more complete tools; like that assignment\ninvolving the visualization\nof 26 different samples from a dataset, as well as calculating some\nstatistical metrics about each sample.\nA sane person would have used the charting features\nin the Excel spreadsheet it was provided in, but that's outside the scope\nof this post.\nI exported to csv immediately and made an incredibly primitive\ntoolkit for embedding Python logic in LaT<sub>E</sub>X. Revisiting it a\ncouple of months later, I refined my toolkit massively and today I\nwould consider the design complete, but alternative implementation\napproaches merit some exploration.</p>\n<p>The first time I attemped glueing my Pythonisms into LaT<sub>E</sub>X,\nmy design was a tiny mapping from a LaT<sub>E</sub>X grammar extension\nto Python formatting key syntax.\nIf I were to write my LaT<sub>E</sub>X code directly in a Python string,\nand attempt to use formatting keys,\nI would probably spontaneously combust. It looks like this:</p>\n<pre><code class=\"language-python\">r\"\"\"\\begin{{document}}\n\\frac{{ {kill} }}{{ {me} }}\n\\end{{document}}\"\"\".format(kill=5, me=10)\n</code></pre>\n<p>That's almost as crufty as chained ternary expressions in JSX.\nBackslash doubling I can avoid by making it a raw string, but that\nisn't an option in all use cases.\nRegardless, I hid this formatting ugliness behind a script, which\nescaped braces for me, and interpretted the characters '&#x3C;&#x3C;' as '{', and\n'>>' as '}'. So now I didn't have to brace every 5 characters, and the\nkeys looked distinct from the LaT<sub>E</sub>X syntax.\nMy dumb and ugly LaT<sub>E</sub>X superset templater took about 5 lines of\nPython code to process, and the source looked like:</p>\n<pre><code class=\"language-python\">\\begin{document}\n\\frac{&#x3C;&#x3C;numerator>>}{&#x3C;&#x3C;denominator>>}\n\\end{document}\n</code></pre>\n<p>Quite literally, all my template processor had to do was replace all braces with\nescaped double braces, and then replace all\ndouble angle brackets with a single formatting brace, thus yielding\nthe valid Python formatting keys, while allowing raw LaT<sub>E</sub>X to look\nat least familiar.\nThen you just produce your values and/or data in your Python script,\nread this template from some file,\nand submit it to Python's formatting functinos with the expected keyword\narguments that you used in the document source\n(e.g. &#x3C;<numerator>>).\nHere's the naive templating implementation:</p>\n<pre><code class=\"language-python\">def load_pytex(path, **kwargs):\n  txt = open(path).read()\n  txt = txt.replace('{','{{').replace('}','}}')    \n  txt = txt.replace('&#x3C;&#x3C;', '{').replace('>>', '}')\n  txt.format(**kwargs)\n  return txt  # or subproc.check_output(['pdflatex' ...])\n</code></pre>\n<p>So this works, but it would be quite annoying to have a Python\ncontext so decoupled from the usage context. Calculating things\nwithout regard to the location in the document, and being\nunable to change the logic while editing the document without\nswitching files.\nCertainly I could do better? So I did something sinful.</p>\n<p>Fake macros in LaT<sub>E</sub>X will make this all look way more T<sub>E</sub>X-savvy.\nLet's add a <code>\\pyeval</code> pseudo-command, and a\n<code>pyexec</code> pseudo-environment so that we can get something\nlike so:</p>\n<pre><code class=\"language-python\">\\begin{pyexec}\nname = 'John'\n\\end{pyexec}\n\nHello I am \\pyeval{' '.join([name,'Smith'])}\n</code></pre>\n<p>Originally I implemented (knowing my transgressions) a naive\nregular expression based implementation, but this has many problems</p>\n<ul>\n<li>I want to ignore false ends in quotes and comments</li>\n<li>I want to allow counting of nested braces in pyeval</li>\n</ul>\n<p>expressions so that you don't need to escape all right\nbraces. (Regular expressions can't find the valid ending\nbrace of a nested expression)\nCheckout the following counter_examples:</p>\n<pre><code class=\"language-python\">\\begin{pyexec}\nhate_you = r'\\end{pyexec}'  # we need to avoid ending if its in a literal\n\\end{pyexec}\n\n\\pyeval{h = {'hello': 'world', 'x': {}}}  # which brace do we end on?\n</code></pre>\n<p>So I couldn't use regular expressions for this, but I still wanted it.\nBecause my LaT<sub>E</sub>X document source would look like this:</p>\n<pre><code class=\"language-python\">\\begin{pyexec}\nfrom scipy.optimize import curve_fit\nfrom random import random as rand\nfrom itertools import count, product as crossproduct\nbin = crossproduct((0,1),repeat=5)\ndata = list(zip(count(), bin))\n# add a count of set bits as a column\nfor row in data:\nd, b = row\nrow.append(b.count(1))\nrandpts = [[rand(),rand()] for _ in range(100)]\n\\end{pyexec}\n\n\\section*{Data Stuff}\n\n\\begin{tabular}{|c|c|}\n\\hline\nDecimal &#x26; Binary &#x26; 1-Bits \\\\\n\\hline\n\\pyeval{'\\n'.join(('&#x26;'.join(map(str,d)) for d in data))}\n% we can extract the above one-liner for reuse in tabular \n% construction and any horizontally partitioned context\n\\hline\n\\end{tabular}\n\n% use unpack+zip hack to get separate lists of x then y coords\nBest Fit: \\pyeval{curve_fit(lambda x,m,b: m*x+b, zip(*randpts))} \n</code></pre>\n<p>Mmmmm... delicious. It looks so much like Python yet so much like LaT<sub>E</sub>X.\nIt's both at once, without crippling either one! It's logic embedded in the document\nmarkup cleanly. So I did go and implement it. Originally I tried using a more\ncomplicated parsing approach, PyParsing, but it turned out to be far too complicated\nfor what was essentially templating. I ended up settling on parsing by character, due\nto the simplicity of the extension. There are a few performance enhancements I could\nmake but I'm not in the need of them right now, and I've noted them for posterity in\nmy README. This is PyLaT<sub>E</sub>X, and I put it on my\n<a href=\"https://github.com/MichaelBelousov/pylatexc\">GitHub</a></p>\n<p>At last, I would argue, that we have a tool more extensible than Excel,\nit's got all of PyPI behind it, with numpy, scipy, and all the packages\nyou could want&#x26;emdash; embedded in your document.\nIf you like this approach, maybe you can be just as sinful and throw it into\nMarkdown, or change up the scripting language to your preference. So long as you\ndon't use php. Even if it's already a templating language.</p>\n<pre><code class=\"language-markdown\">My Document\n===========\n\n```pyexec\nimport csv\ndata = list(csv.reader('mycsv.csv'))\n```\n`>>> '\\n'.join(data)`\n</code></pre>\n<p>And as a final note, check out <a href=\"https://typora.io/\">Typora</a>\nother cool ways to not use Office products. I don't actually use it, but the LaT<sub>E</sub>X\nin Markdown makes me want to. Even if I'm not in school any more.</p>\n<style>\nspan.vim {\n    font-size: 3pt;\n}\n</style>","frontmatter":{"date":"May 04, 2019","path":"/blog/empowering-LaTeX","title":"Empowering LaTeX (PyLaTeXc)"}}},{"node":{"html":"<p>For my computational geometry course, I and a small team of my peers wrote a\nvisualization comparing the naive and the Melkman convex hull\nfinding algorithms, with some pedagogical narration. It\nwas a fun opportunity to really learn Elm for HTML5 content authoring, and SVG rendering.\n<a href=\"https://mikemikeb.com/convex-hull-visualization/\">See it here</a>.</p>\n<p>The narration needs better interactivity, the style is pretty poor and there's no mobile support,\nso I need to come back and polish it some night. It was made in <a href=\"https://elm-lang.org/\">elm</a>.</p>","frontmatter":{"date":"May 04, 2019","path":"/blog/convex-hull-visualization","title":"Melkman Algorithm Visualization"}}},{"node":{"html":"<p>Shout-out to Bill Wurtz.</p>\n<p>His website is a real treat, it harkens back to the early web styles (or lack thereof). It reminds me of a simpler time when websites were awesome.</p>\n<p>Check it out: <a href=\"https://billwurtz.com\">billwurtz.com</a></p>","frontmatter":{"date":"August 28, 2018","path":"/blog/billwurtz","title":"Bill Wurtz"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":true}}}