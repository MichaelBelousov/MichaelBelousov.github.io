{"componentChunkName":"component---src-components-blog-page-tsx","path":"/blog/iterators-and-generators-are-better-than-array-prototype/","result":{"data":{"markdownRemark":{"html":"<p>A while back, I was concerned about the wastefulness of JavaScript's\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map\"><code>Array.prototype.map</code></a>\nand <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter\"><code>Array.prototype.filter</code></a>\nfunctions, really all of JavaScript's canonical functional sequence programming builtins.\nIf you're unaware, these methods always allocate an entire new array. While this is fine in some cases, it enables several\ndumb performance pitfalls, and doesn't allow you to use these functions in performance-sensitive hotpaths of your application.\nNot to mention that these methods only exist on JavaScript's <code>Array</code> type, so you need to convert all iterators (e.g. <code>Map</code>, <code>Set</code>)\ninto an array with <code>Array.from</code>, wasting more allocations. Here we'll build an efficient, elegant alternative using lazy evaluated generators,\nand at the end I provide a TypeScript implementation with heaps of fancy functional list operations, all efficient as heck.</p>\n<p>Returning to the horror of JavaScript's original design, take for instance the following example:</p>\n<pre><code class=\"language-js\">([1,2,3]\n    .map(x => x*3)\n    .filter(x => x%2 == 0)\n    .map(x => `${x}`)\n    .concat([10, 11])\n)\n</code></pre>\n<p>Simple enough, right? The result is <code>['6', 10, 11]</code>. But in fact this code will allocate 4 distinct intermediate arrays, and in the worst case\nall of them will be the same size as the source array (if say, the filter didn't filter anything).\nIf we were performing this on an array of 10 million records, we'd suddenly have to\nallocate 40 million records, 30 million of which we discard immediately. Perhaps an advanced optimizing JavaScript runtime, like Chromium/V8's\nTurboFan, will JIT-out the problem, but the standard library design is just poor in my opinion. There are lots of cases where your\ncode will not have been churned through some optimizer and this bloat isn't hard to design out of the equation in the first place.\nInstead, let's implement our own similar functional list processing API with better performance thanks to lazy evaluation, and we'll do\nso with modern JavaScript generators.</p>\n<p>A generator is a functional coroutine, effectively a function that can <em>yield</em> its ownership over the program execution flow, and\nconfusingly also <em>yield</em> individual elements as its iterated over as an iterable. To make one in JavaScript, you use a function statement/expression with\nthe <code>*</code> marker.</p>\n<pre><code class=\"language-js\">function* myGenerator() {\n    yield 5\n    yield 2\n}\n</code></pre>\n<p>When <code>myGenerator</code> called, it returns an iterator which on its next method, runs the underlying coroutine until it yields, which would be\nat the <code>yield</code> keyword. This way, callers can run their own code in between yielded elements, and even stop asking for more elements.\nWith the <code>Array.prototype.map</code> function design, you need to allocate the entire array before you can iterate through it. This ability\nto not iterate until we need to, and even stop iteration is the concept of lazy evaluation that will free us from unnecessary allocations.</p>\n<p>Let's combine our fancy generator with JavaScript's iterator interface to get an iterable literal:</p>\n<pre><code class=\"language-js\">my_iter = {\n    *[Symbol.iterator]() {\n        yield 1\n        yield* [2,3]\n    }\n}\n</code></pre>\n<p>So we're declaring an object with the hidden <code>Symbol.iterator</code> property to show how to get an iterator of the object, and using the\nobject generator property shorthand syntax to make it a generator. For completeness I also added an example of the <code>yield*</code> syntax which\nlets our generator yield from other iteratables. Now we can do something interesting with our generators.</p>\n<pre><code class=\"language-js\">function* map(iterable, mapFunction) {\n    for (const item of iterable) yield mapFunction(item)\n}\n</code></pre>\n<p>And that's basically it to <code>map</code>. We'll make the API more elegant later. We can now do the following:</p>\n<pre><code class=\"language-js\">[...map(map([1,2,3], x => x*3), x => `${x}`)]\n</code></pre>\n<p>You may be missing the trailing function syntax which is the main advantage to having <code>map</code> be a method of <code>Array</code>s, but as I said we'll be\nmaking it elegant later. If you run this code in your local JavaScript runtime, be it browser or local,\n(I actually originally was inspired to write this code while using <a href=\"https://bellard.org/quickjs/\">quickjs</a> which doesn't optimize this stuff afaik)\nyou'll notice that the spread syntax forces the iteration of the lazy iterable into an array, for us to view. When this code is running the spread syntax\ncalls next on the outer map iterable. To get the first element, it calls next on the inner map. The inner map\nruns the loop, sets <code>item</code> to <code>1</code>, then runs <code>x => x*3</code> over it, yielding <code>3</code>. The outer map sets its <code>item</code> to <code>3</code> after receiving it as the first element\nfrom inner map it is wrapping, and runs <code>x => `${x}`</code> yielding <code>'3'</code>. This repeats for all elements until the Array has pushed all 3 elements and is now\n<code>['3', '6', '9']</code>. The point is, the instructions for the <code>map</code> calls are glued together when implemented via coroutine, as if you wrote only one <code>map</code> call\npractically. Now let's make <code>filter</code>.</p>\n<pre><code class=\"language-js\">function* filter(iterable, predicate) {\n    for (const item of iterable)\n        if (predicate(item))\n            yield item\n}\n</code></pre>\n<p>Again, easy. Now let's try to make these two functions as elegant as <code>[1,2,3].map(x => x*4).filter(x => x &#x3C; 10)</code>.\nThe best way to do this, is be as close to the original API as possible. Let's take advantage of <code>Array.from</code>, and make our own\n<code>Lazy.from</code> method for all our lazy-evaluation needs. This way, we can have <code>Lazy.prototype.map</code> and <code>Lazy.prototype.filter</code>, and\nmost code will just be a <code>Lazy.from(...)</code> away from making no copies.</p>\n<pre><code class=\"language-js\">class Lazy {\n    constructor(iterable) {\n        this.iterable = iterable\n    }\n    static from(iterable) {\n        return new Lazy(iterable)\n    }\n    [Symbol.iterator]() {\n        return this.iterable[Symbol.iterator]()\n    }\n}\n</code></pre>\n<p>Alright, so we can wrap iterables, but how can we map over them? We'll bring back our anonymous iterable to do so:</p>\n<pre><code class=\"language-js\">class Lazy {\n    //...\n    map(mapFunc) {\n        const _this = this\n        return Lazy.from({\n            *[Symbol.iterator]() {\n                for (const t of _this)\n                    yield mapFunc(t)\n            }\n        })\n    }\n}\n</code></pre>\n<p>I like to let the code speak for itself normally but this can be a bit to parse. We return a new <code>Lazy</code> object,\nwrapping a new anonymous iterable mapping over this iterable. Since our <code>Lazy</code> object is an iterable (it implements <code>Symbol.iterator</code>)\nwe just need to iterate over it. Unfortunately, in the anonymous object's method <code>this</code> would refer to the new anonymous object,\nnot the original <code>Lazy</code> instance, so we create an alias to that <code>this</code> reference, <code>_this</code>, and reference it from our closure.\nThis pattern is incredibly powerful, and we'll do filter pretty much the exact same way.</p>\n<pre><code class=\"language-js\">class Lazy {\n    //...\n    filter(predicate) {\n        const _this = this\n        return Lazy.from({\n            *[Symbol.iterator]() {\n                for (const t of _this)\n                    if(predicate(t))\n                        yield t\n            }\n        })\n    }\n}\n</code></pre>\n<p>Now we can expand our horizons and implement other array methods like <code>concat</code>, and <code>forEach</code>.</p>\n<pre><code class=\"language-js\">const isIterable = arg => typeof arg === \"object\" &#x26;&#x26; Symbol.iterator in arg\n\nclass Lazy {\n    concat(...args) {\n        const _this = this\n        return Lazy.from({\n            *[Symbol.iterator]() {\n                yield* _this\n                for (const arg of args)\n                    if (isIterable(arg)) yield* arg\n                    else yield arg\n            }\n        })\n    }\n    forEach(func) {\n        for (const t of this) func(t)\n    }\n}\n</code></pre>\n<p>And to get crazy, we can do some recursion with this technique and implement <code>Array.prototype.flat</code></p>\n<pre><code class=\"language-js\">flat(depth=1) {\n    const _this = this\n    if (depth &#x3C;= 0) return this\n    else return Lazy.from({\n        *[Symbol.iterator]() {\n            for (const item of _this) {\n                if (isIterable(item))\n                    yield* Lazy.from(item).flat(depth - 1)\n                else yield item\n            }\n        }\n    })\n}\n</code></pre>\n<p>The morale of the story is once you get oriented, generators can make\nefficient, readable and effortlessly composable code, effectively reducing the\nsins of JavaScript. I think the 'anonymous iterable'\nidiom is a real gem in TypeScript, with generators also shining. Hopefully you decide\nto use something like this over lowering yourself to mutable <code>Array.prototype.push</code>\nin your performance-sensitive hotspots. Although I'm yet to [micro]benchmark the two.</p>\n<p>As promised, here's a decently extensive <code>Lazy</code> implementation in TypeScript. I actually\nmade one simplification and was too lazy (trivial pun intended) to double check that it\ncompiles, please <a href=\"mailto:mikemikeb@protonmail.com\">bug me</a> if it doesn't.</p>\n<p>Eventually if I find a good untaken name I'll add more test cases and publish this to <a href=\"https://www.npmjs.com/\">npm</a>.\nIf you'd like to do it yourself for me for some reason, please involve me, I'd love to share\nthe ownership. Please use away internally however you like.</p>\n<pre><code class=\"language-ts\">// Typescript@4.0 probably simplifies or allows better alternative typings for\n// some of these\n\n/** return whether arg is T or an iterable of T */\nfunction isIterable&#x3C;T>(arg: T | Iterable&#x3C;T>): arg is Iterable&#x3C;T> {\n    return typeof arg === \"object\" &#x26;&#x26; Symbol.iterator in arg\n}\n\n/** iterable wrapper for functional programming with lazy composition */\nexport default class Lazy&#x3C;T> implements Iterator&#x3C;T> {\n    static from&#x3C;T>(iterable: Iterable&#x3C;T>) {\n        return new Lazy&#x3C;T>(iterable)\n    }\n\n    public constructor(protected iterable: Iterable&#x3C;T>) {}\n\n    [Symbol.iterator](): Iterator&#x3C;T> {\n        return this.iterable[Symbol.iterator]()\n    }\n\n    public filter(predicate: (t: T) => boolean) {\n        const _this = this\n        return Lazy.from({\n            *[Symbol.iterator]() {\n                for (const t of _this)\n                    if (predicate(t))\n                        yield t\n            }\n        })\n    }\n\n    public map&#x3C;U>(transform: (t: T) => U) {\n        const _this = this\n        return Lazy.from&#x3C;U>({\n            *[Symbol.iterator]() {\n                for (const t of _this)\n                    yield transform(t)\n            }\n        })\n    }\n\n    public flat(depth=1) {\n        const _this = this\n        if (depth &#x3C;= 0) return this\n        else return Lazy.from({\n            *[Symbol.iterator]() {\n                for (const item of _this) {\n                    if (isIterable(item))\n                        yield* Lazy.from(item).flat(depth - 1)\n                    else yield item\n                }\n            }\n        })\n    }\n\n    public concat(...args: (Iterable&#x3C;T> | T)[] ): Lazy&#x3C;T> {\n        const _this = this\n        return Lazy.from({\n            *[Symbol.iterator]() {\n                yield* _this\n                for (const arg of args)\n                    if (isIterable(arg)) yield* arg\n                    else yield arg\n            }\n        })\n    }\n\n    public forEach(doSomething: (t: T) => void) {\n        for (const item of this)\n            doSomething(item)\n    }\n\n    public take(n: number): Lazy&#x3C;T> {\n        const _this = this\n        return Lazy.from({\n            *[Symbol.iterator]() {\n                let i = 0\n                for (const item of _this) {\n                    if (!(i &#x3C; n)) break\n                    yield item\n                    i++\n                }\n            }\n        })\n    }\n\n    public reduce&#x3C;Result>(callback: (prev: Result, curr: T, index: number) => Result, initial: Result): Result {\n        let result = initial\n        let i = 0\n        for (const curr of this) {\n            result = callback(result, curr, i)\n            i++\n        }\n        return result\n    }\n\n    public toSet(): Set&#x3C;T> {\n        const result = new Set&#x3C;T>()\n        for (const item of this) \n            result.add(item)\n        return result\n    }\n\n    public some(predicate: (t: T) => boolean): boolean {\n        for (const item of this)\n            if (predicate(item)) return true\n        return false\n    }\n\n    public every(predicate: (t: T) => boolean): boolean {\n        return !this.some(t => !predicate(t))\n    }\n    \n    public empty(): boolean {\n        const item = this.next()\n        return item.done\n    }\n\n    public sort(...[sortFunc]: Parameters&#x3C;Array&#x3C;T>[\"sort\"]>) {\n        return Lazy.from([...this].sort(sortFunc))\n    }\n\n    public get length() {\n        let i = 0\n        for (const item of this) i++\n        return i\n    }\n\n    public includes(t: T) {\n        for (const item of this) if (item === t) return true\n        return false\n    }\n\n    public find(predicate: (t: T) => boolean) {\n        for (const item of this) if (predicate(item)) return item\n        return false\n    }\n}\n</code></pre>","frontmatter":{"title":"Lazy Javascript Iterables via Generators","path":null,"date":"October 06, 2020"}}},"pageContext":{"slug":"/blog/iterators-and-generators-are-better-than-array-prototype/"}}}