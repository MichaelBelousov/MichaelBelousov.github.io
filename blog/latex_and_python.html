<div class="mikpanel blog">
    <h3 style="margin:1pt;">Empowering LaTeX (PyTeXc)</h3>
    <h5 style="margin:1pt;">April 4, 2019</h5>

    <p>
    I've been using LaTeX primarily for typesetting my homeworks and
    varying reports and texts in my undergraduate education. It's
    overkill and my assignments are often undeserving, but the 
    formula rendering is exquisite. For the classes that truly
    deserve it, it's worth it all. <!-- maybe move in to the middle
    of last paragraph? -->
    </p>

    <p>
    The one nagging gap in my homework development stack early on
    was an itch for 
    programmability, that trait which Excel is alleged to have.
    But I have a gripe with Excel, which I consider to be a
    scripting language for the uninitiated, feeble-minded bottom
    feeders.
    Personally, I've always kicked up a Python interpreter any
    time I needed a calculation, and I quickly began depending on
    Python for more intense derivations and data routines. I scratched
    up a utility module for producing LaTeX tables and pgfplots graphics
    from various data formats, and used it frequently with minimal
    copy and paste glue (thank you Cygwin's 
    <code>/dev/clipboard</code> when I was using Windows).
    </p>

    <p>
    But larger projects begged for more complete tools; like that time
    I was assigned the visualization and statistical metric calculations
    of 26 different samples from a dataset.
    A sane person would have used the charting features
    in the Excel spreadsheet it was provided in, but sanity is not
    my priority.
    I exported to csv immediately and made an incredibly primitive 
    toolkit for embedding Python logic in LaTeX. Revisiting it a
    couple of months later, I refined my toolkit massively and I 
    would consider the design complete, while alternative implementation
    approaches merit some exploration.
    </p>

    <p>
    The first time I attemped gluing my Pythonisms into LaTeX, 
    my design was a tiny mapping from a LaTeX grammar extension
    to Python formatting key syntax.
    If I were to write my LaTeX code directly in a Python string,
    and attempt to use formatting keys,
    I would probably spontaneously combust. Here's a demonstration:
    </p>
    <p class=terminal>
    r"""\begin{{document}}
    \frac{{ {kill} }}{{ {me} }}
    \end{{document}}""".format(kill=5, me=10)</p>
    <p>
    That's almost as crufty as chained ternary expressions in JSX.
    Backslash doubling I can avoid by making it a raw string, but that
    isn't an option in all use cases.
    Regardless, I hid this formatting ugliness behind a script, using a
    scripted LaTeX language extension to specify Python formatting keys
    that wouldn't require me to escape braces every 5 characters.
    My dumb and ugly LaTeX superset templater took about 5 lines of 
    Python code to process, and looked like so:
    </p>
    <pre class=terminal>
    \begin{document}
        \frac{&lt;&lt;numerator&gt;&gt;}{&lt;&lt;denominator&gt;&gt;}
    \end{document}
    </pre>

    <p>
    Quite literally, all my code has to do is replace all braces with 
    escaped double braces, and then replace all 
    double angle brackets with a single formatting brace, thus yielding
    the valid Python formatting keys, while allowing raw LaTeX to look
    at least familiar.
    Then you just produce your values and/or data in your Python script, 
    read this template from some file,
    and submit it to the Python formatter with the expected keyword
    arguments that you used in the document source 
    (e.g. &lt;&lt;numerator&gt;&gt;).
    Here's the naive templating implementation:
    </p>
    <pre class=terminal>
    def load_pytex(path, **kwargs):
        txt = open(path).read()
        txt = txt.replace('{','{{').replace('}','}}')    
        txt = txt.replace('&lt;&lt;', '{').replace('&gt;&gt;', '}')
        txt.format(**kwargs)
        return txt  # or subproc.check_output(['pdflatex' ...
</pre>
    <p>
    So this works, but it would be quite annoying to have a Python
    context so decoupled from the usage context. Calculating things
    without regard to the location in the document, and being
    unable to change the logic while editing the document without
    switching files.
    Certainly we can do better? Let's do something sinful. 
    </p>
    <p>
    Fake macros in LaTeX will make this all look way more TeX-savvy. 
    Let's add a <code>\pyeval</code> pseudo-command, and a 
    <code>pyexec</code> pseudo-environment so that we can get something 
    like so:
    </p>
    <pre class=terminal>
    \begin{pyexec}
        name = 'John'
    \end{pyexec}

    Hello I am \pyeval{' '.join([name,'Smith'])}
    </pre>
    <p>

    Originally I implemented (knowing my transgressions) a naive
    regular expression based implementation, but this has many problems

    <ul>
        <li> I want to ignore false ends in quotes and comments
        <li> I want to allow counting of nested braces in pyeval
            expressions so that you don't need to escape all right
            braces. (Regular expressions can't find the valid ending
            brace of a nested expression)
    </ul>
    Checkout the following examples:
    </p>
    <pre class=terminal>
    \begin{pyexec}
        hate_you = r'\end{pyexec}'
    \end{pyexec}

    \pyeval{h = {'hello': 'world', 'x': {}}}  # which brace do we end on?
    </pre>
    <p>
    So let's see what our LaTeX document source would look like
    while using that.
    </p>
    <pre class=terminal>
    \begin{pyexec}
        from scipy.optimize import curve_fit
        from random import random as rand
        from itertools import count, product as crossproduct
        bin = crossproduct((0,1),repeat=5)
        data = list(zip(count(), bin))
        # add a count of set bits as a column
        for row in data:
            d, b = row
            row.append(b.count(1))
        randpts = [[rand(),rand()] for _ in range(100)]
    \end{pyexec}

    \section*{Data Stuff}

    \begin{tabular}{|c|c|}
        \hline
        Decimal &amp; Binary &amp; 1-Bits \\
        \hline
        \pyeval{'\n'.join(('&amp;'.join(map(str,d)) for d in data))}
        % we can extract the above one-liner for reuse in tabular 
        % construction and any horizontally partitioned context
        \hline
    \end{tabular}

    % use unpack+zip hack to get separate lists of x then y coords
    Best Fit: \pyeval{curve_fit(lambda x,m,b: m*x+b, zip(*randpts))} 
    </pre>

    <p>
    Now, the last thing to do is to use data files for your tables and
    your graphs and you've got a fully programmable document typesetting
    environment. You can even write a small latextools module like I have,
    for any common utilities like that nested join in the tabular that 
    produces cells for a 2-dimensional Python iterable.
    At last, I would argue, that we have a tool more extensible than Excel, 
    it's got 
    all of PyPI behind it, with numpy, scipy, and all the packages
    you could want&emdash; embedded in your document.
    The next step is making sure we have a competent graphing utility,
    that can be integrated with our typesetter and scripting.
    </p>

    <!-- TODO: make more introductory for LaTeX and -->

    <h4>Ingredient 3: Graphing - pgfplots</h4>
    <p>
    I would say you could use any graphing utility and include it as
    any media you want, but that won't let you take advantage of the
    combination we've developed thus far. If you want to fully use 
    LaTeX and your scripting language, use a LaTeX
    integrated graphing package like pgfplots<sup>9</sup>. That way
    your script templating can be used in the graphs.
    Finally, the only thing
    that remains for our recipe is a substitute of Microsoft's Visio, 
    so that we can fill our documents with appropriate diagrams.
    </p>

    <h4>Ingredient 4: Diagramming and Visualization - *</h4>
    <p>
    There are a lot of diagramming tools out there.
    I've used primarily Blender, Google Drawings, Gimp,
    and some InkScape.
    Google Drawings is great for shapely diagrams, flowcharts, and
    etc. I use blender for more intense graphics and visualizations, 
    but I don't recommend learning it for typesetting.
    If Google Drawings is not independent enough, then
    learn Inkscape or even better Tikz.
    This ingredient is definitely the one
    that I have worried about the least. Diagramming isn't
    something I've had to make programmable often enough,
    and there are a plenty of tools for designing your diagrams.
    If you've needed to do it before, chances are you already have
    one, and you can throw that application's output into LaTeX
    properly yourself.
    </p>

    <!-- TODO: write a short compiler wrapper -->

    <p>
    And now we can do something like the following:
    </p>


    <h4>Substitute for 1: Markdown</h4>
    <p>
    An alternative markup language to LaTeX, that I use for taking 
    notes in classes, is Markdown<sup>10</sup>.
    Markdown typically renders to HTML but you can use tools like
    pandoc to convert it to a tradional paper style.
    If you've ever used GitHub, you've probably
    seen rendered Markdown even if you didn't realize it. Most flashy
    READMEs are rendered Markdown.
    You could also use ReStructured Text or some 
    other minimal markup language, so long as you can render it out
    to your required medium.
    </p>
    <p>
    The most useful things about embracing Markdown, are definitely
    the effortless simplicity of the language and the decoupling 
    of styling from content with CSS. Markdown will be much easier
    to learn than LaTeX, and you can still be inspired by our script 
    embedding and use a custom XML tag (Markdown includes HTML)  
    for Python embedding. It might look like:
    </p>
    <pre class=terminal>
    My Document
    ===========

    &lt;pyexec&gt;
    from operator import mul
    &lt;/pyexec&gt;

    _this is my document_, 
    and I **like** the number &lt;pyeval&gt;mul(5,3)&lt;/pyeval&gt;
    </pre>
    <p>
    You could even use the inline source syntax:
    </p>
    <pre class=terminal>
    My Document
    ===========

    ```pyexec
    import csv
    data = list(csv.reader('mycsv.csv'))
    ```

    </pre>
    <p>
    You could go a whole another step and integrate some LaTeX math
    rendering, for the sweet, sweet mathematical formulas.
    Check out packages like <a href=""><i>katex</i></a> 
    to embed LaTeX in your markdown
    where you're already embedding Python. 
    At that point I hope you can somehow embed Python in the LaTeX
    embedded
    in your Markdown without getting hurt, but it would bring together
    the best of all worlds. Programmability (Python), extensibility (PyPI), 
    simplicity (Markdown), and beauty when you need it (LaTeX).
    </p>

    <h4>Substitution for 2: Other Scripting Language</h4>
    <p>
    Are you the last person on earth, besides myself, who might like Perl? <br/>
    Are you twistedly enamored by the parasite that is PHP? <br/>
    Perhaps you're a node.js &gt; Python person, <br/>
    or maybe you want to focus on R and its visualizations. <br/>
    If you think about it, the same principles of what we're doing 
    currently apply, just hope that templating with your language is 
    as easy to implement as it was for Python.
    </p>
    <pre class=terminal>
    \begin{CppExec}
        //someone should totally do this with Cling
        #include &lt;vector&gt;
        #include &lt;iostream&gt;
        #include &lt;algorithm&gt;
        std::vector&lt;int&gt; ints = {1,7,5,9};
        template&lt;typename T&gt;
        operator&lt;&lt;(std::ostream& os, const std::vector<T>& vec) {
            for (const auto& x : vec) os &lt;&lt; x &lt;&lt; ", ";
        }
        //I'd use R but I don't use it enough to have a working vocabulary
    \end{CppExec}

    \section*{C++ isn't right for this}

    If I were writing a C++ latex templater, I would probably source
    transform each cpptex file into a C++ program emits the latex
    code. Also, you could probably write some of this stuff in lex/yacc

    \CPPeval{ std::sort(ints), ints }
    </pre>

    <p>
    And there we go. So you can take this stuff here and make a script
    wrapping around your favorite TeX compiler to evaluate your scripted
    expressions first as part of a compilation pipeline. Or you can see
    If you want to make this a production tool, go prevent
    the string literal end marker issue by ignoring string literals, 
    and research LuaTeX and general TeX packages and extensions to see 
    where a Python evaluation step can be added. I would
    appreciate it certainly. But that's a lot of work and while I'm 
    the only person doing this still, I'll just stick to my &lt;20 lines
    of code that works 99.99% of the time.
    </p>

    <p>
    Oh, and if you don't want to use any of this, 
    go check out Libre/Open Office. 
    </p>

    <p>
    Alternative Solutions:
    <ul>
        <li> Markdown renderer plugin
        <li> LuaTeX plugin
        <li> lex/yacc implementation
        <li> not regular expressions
        <li> the C preprocessor?
        <li> <a href="">cog</a>
    </ul>
    </p>

    <p>
    Appendix/Glossary:
        </p><ol start=0>
            <li>
                <b>IDE</b>: An application used to make Computer Science
                students even dumber than they already are.
            </li>
            <li>
                <b>DSL</b>: domain specific language. 
                Wouldn't it be funny to have a dystopian future 
                where people can only communicate via powerpoints?
            </li>
            <li>
                <b>*.docx</b>: The Microsoft Word file format. 
                Some compressed XML if I recall correctly and there used 
                to be a .doc format too. 
            </li>
            <li>
                <b>Convenience</b>: 
                I'll have a post on the "convenience" of the 
                Software-as-a-Service/non-self-hostable product model
                to clarify what I mean there. The post is currently a WIP.
            </li>
            <li>
                <b>This does not account for leap years</b>: 
                Growing up is learning that you will have to give up 
                and use MS Office. I suppose then I have grown up because
                I do use MS Office when it's necessary.
            </li>
            <li>
                <b>WYSIWYG</b>: What You See Is What You Get
            </li>
            <li>
                <b>TeX</b>: <a href="https://tex.stackexchange.com/questions/49/what-is-the-difference-between-tex-and-latex">The difference between TeX, and LaTeX</a>
            </li>
            <li>
                <b>PHP</b>: As much as I laugh at PHP, 
                <a href="https://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/">read the rant</a>, it's probably the easiest 
                to do templating with since that's part
                of the design of the language. Although have fun using it
                in LaTeX.
            </li>
            <li>
                <b>LuaTeX</b>: An extensible TeX compiler. I haven't
                looked into it much but it is likely the best candidate for
                embedding Python in the TeX compilation process. Though it's
                likely easier to embed Lua, one might think. 
            </li>
            <li>
                <b>pgfplots</b>: <a href="http://pgfplots.sourceforge.net/gallery.html">Learn by example</a>
            </li>
            <li>
                <b>Markdown</b>: Proof that no one who writes blogposts should be writing pure HTML like I am currently. How can I even tolerate writing out ampersand literals...
            </li>
        </ol>
    <p></p>


</div>
<style>
span.vim {
    font-size: 3pt;
}
</style>
