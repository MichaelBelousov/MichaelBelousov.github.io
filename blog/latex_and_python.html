<div class="mikpanel blog">
    <h3 style="margin:1pt;">A Guide to Avoiding Office Products like the Plague</h3>
    <h5 style="margin:1pt;">September 25, 2018</h5>

    <p>
    Microsoft is fine. They have some good (great) stuff. I love TypeScript,
    C# has some excellent design choices as a language, even if I don't
    really use it much (e.g. struct vs. class semantics). But this is 
    about Microsoft Office, tenacious the corporate DSL<sup>1</sup>.
    </p>

    <p>
    I used Word as a main word processor for several years, it's a fine, 
    oft well-thought-out suite of tools.
    I've even used excel, though I'm no spreadsheet savant. But I don't
    use either of them anymore, and haven't for a couple of years. 
    In my undergraduate senior year (presently), 
    I have this professor leading our Senior Design Project. 
    He's an alright guy; yet it's become blatantly
    obvious that he's a sycophant of the devil. He requires our group
    submit all texts in <i>.docx</i><sup>2</sup> format. That is probably 
    the most oppressive constraint I've ever received in my academic career. 
    I have always had the sweet, sweet, sanctity of the PDF to depend on.
    </p>
    <p>
    Well anyway, it prompted me to think over my toolset and how I've 
    been writing essays, reports, diagrams, tables, and graphs for 
    the last two academic seasons. And I wanted to share.
    </p>

    <p>
    If you, like myself, enjoy rejecting Facebook, Google, or you know, 
    anything that is convenient, then here's my recipe to avoiding 
    Microsoft Office 365 days of the year 
    (not accounting for leap years)<sup>3</sup>.
    </p>

    <h5>Ingredient 1: LaTeX</h5>
    <p>
    OK, so you can't really get away with not having typesetting.
    The best and boldest choice is the engineer's typesetter. 
    Steep-learning-curve LaTeX.  I'll offer an easier (though 
    perhaps less complete) substitution later.
    Firstly, I pronounce it as "laaaaaaaa-(sing it)-tech", unlike that 
    rubber that I am allergic to.
    LaTeX is considered difficult to learn but if you want a beautiful
    report tool which uses plaintext for input, then LaTeX will do more 
    than quite well.  With plaintext, the chief advantage is that you 
    can use your favorite text 
    ed<span style="font-size:3">v</span>i<span style="font-size:3">m</span>tor.
    All that's really left once having LaTeX is an itch for programmability.
    That trait which, for example, Microsoft Excel is alleged to have. 
    LaTeX does initially to embed logic, which you may want for
    calculating statistical metrics, curve fittings, etc. You can do it
    separately, but if your data changes, you need to reintroduce said
    changes.
    </p>

    <h5>Ingredient 2: Scripting Language</h5>
    <p>
    I use Python as my example, since that's what I use, but you can 
    use PHP for all I care. The idea is simple. Unlike your Office 
    document which will likely require some fancy APIs (Office 365) 
    or at least XML parsing to edit, LaTeX source files are just, 
    you know, plaintext. So you can edit them anyhow
    you like. The first time I ever did this, my approach was a tiny
    mapping from LaTeX source to Python formatting key syntax.
    If I were to just write it directly in Python source,
    I would probably spontaneously combust. Take a look:
    </p>
    <p class="terminal">
    \\begin{{document}}
        \\frac{{kill}}{{me}}
    \\end{{document}}
    </p>
    <p>
    That's almost as bad as chained ternary expressions with JSX.
    So I hid that behind a script, and instead created a simple syntax for 
    keyed formatting. My LaTeX superset takes about 5 lines of python code,
    and looks like so:
    </p>
    <pre class="terminal">
    \begin{document}
        \frac{&lt;&lt;numerator&gt;&gt;}{&lt;&lt;denominator&gt;&gt;}
    \end{document}
</pre>

    <p>
    Quite literally, all my code has to do is replace all braces with 
    escaped double braces, ditto for backslashes, and then replace all 
    double angle brackets with a single formatting brace. 
    Then you just have your values and or data in python, read the file
    and submit it to the Python formatter with the expected keyword
    arguments that you used in the document source.
    Later, we can even add a function to translate python 2-dimensional
    lists into the tabular cell format of LaTeX (you can do it in one line),
    which will make it easy to throw tables together.
    So anyway, here's an example formatting/loading function on the
    previous installment of Python embedding in LaTeX:
    </p>
    <pre class="terminal">
    def load_pytex(path):
        txt = open(path).read()
        txt = txt.replace('{','{{').replace('}','}}')    
        txt = txt.replace(r'\', r'\\')
        txt = txt.replace('&lt;&lt;', '{').replace('&gt;&gt;', '}')
        txt.format(**vars)
        return txt  # or subproc.check_output(['pdfLaTeX' ...
</pre>
    <p>
    So this works, but it would be quite annoying to have a python
    context so decoupled from the usage context. Calculating things
    without regard to the location in the document, and being
    unable to change the logic while editing the document without
    switching files.
    Certainly we can do better? Let's do something even more
    sinful. 
    </p>
    <p>
    Fake macros in LaTeX will make this all look way more TeX-savvy. 
    Let's add a <code>\pyeval</code> pseudo-command, and a 
    <code>\pyexec</code> pseudo-environment so that we can get something 
    like so:
    </p>
    <pre class="terminal">
    \begin{pyexec}
        name = 'John'
    \end{pyexec}

    Hello I am \pyeval{' '.join([name,'Smith'])}
    </pre>
    <p>
    Our environment can't be nested (the content is Python, not LaTeX...),
    so we will use regular expressions to do this very quickly.
    The real caveats that exist are an evaluation of a dictionary literal
    (or any braces-containing construct), or valid Python code containing
    the environent end marker, e.g.:
    </p>
    <pre class="terminal">
    \begin{pyexec}
        hate_you = r'\end{pyexec}'
    \end{pyexec}

    \pyeval{ h = {'hello': 'world'} } # which brace do we end on?
</pre>
    <p>
    For simplicity, and since this is our own hack and not a production
    solution, we'll assume no one has used the end marker, and we'll
    require escaping of right braces in the \pyeval command. Stop
    and think of the regular expression for capturing all text
    between the pyexec environment opening and ending marker. Then think
    of the regular expression for the <code>\pyeval</code> argument,
    recalling that it it cannot end on an backslash-escaped right brace.
    If you come up with better regular expressions, let me know.
    As a sidenote, to achieve a production solution would involve 
    perhaps some [Lua]<sup>4</sup>TeX compiler plugin or something
    fancy. I've never made any LaTeX packages, so I'm not certain to
    what extent I can inject Python into them. But, here's a simple
    implementation or our idea:
    </p>
    <pre class="terminal">
    import re
    from textwrap import dedent
    def render_pytex(path):
        src = open(path).read()
        scope = {}
        def pyexec(match):
            exec(dedent(match[1]), scope)
            return ''
        src = re.sub(r'\\begin\{pyexec\}\n(.*?)\n\\end\{pyexec\}',
                      pyexec, src, flags=re.MULTILINE)
        src = re.sub(r'\\pyeval\{(.*?)(?&lt;!\\)\}',
                     lambda t: eval(t[1].replace(r'\}','}', scope), 
                     src) 
    </pre>
    <p>
    So let's see what our LaTeX document source would look like
    while using that.
    </p>
    <pre class="terminal">
    \begin{pyexec}
        from scipy.optimize import curve_fit
        from random import random as rand
        from itertools import count, product as crossproduct
        bin = crossproduct((0,1),repeat=5)
        data = list(zip(count(), bin))
        # add a count of set bits as a column
        for row in data:
            d, b = row
            row.append(b.count(1))
        randpts = [[rand(),rand()] for _ in range(100)]
    \end{pyexec}

    \section*{Data Stuff}

    \begin{tabular}{|c|c|}
        \hline
        Decimal &amp; Binary &amp; 1-Bits \\
        \hline
        \pyeval{'\n'.join(('&amp;'.join(map(str,d)) for d in data))}
        \hline
    \end{tabular}

    # use unpack+zip hack to get list of x and y coords
    Best Fit: \pyeval{curve_fit(lambda x,m,b: m*x+b, zip(*randpts))} 
    </pre>

    <p>
    Now, the last thing to do is to use data files for your tables and
    your graphs and you've got a fully programmable document typesetting
    environment. You can even write a small LaTeX-tools module like I have,
    for any common utilieis like that nested join in the tabular that 
    produces cells for a 2-dimensional python iterable.
    But now, we have an extension arguably more extensible than Excel, 
    it's got 
    all of PyPI behind it, with numpy, scipy, and any wrapped-C library
    you could want&emdash; embedded in your document. The only thing
    that remains for our recipe is a replacement of Microsoft's Visio, 
    so that we can fill our documents with informative diagrams.
    </p>

    <h5>Ingredient 3: Whatever</h5>
    <p>
    There are a lot of diagramming tools out there.
    I've used primarily Blender and Google Drawings,
    the latter for easy diagramming and the former for
    more intense graphics. If Blender is too hard (it's not worth learning
    to write papers), and Google Drawings not independent enough, then
    learn Inkscape or Tikz, etc. *.svg is a good format for vector images
    and has no resolution limits. This ingredient is definitely the one
    that I have not worried about the most. Diagramming will depend
    a lot on what it is that you are diagramming, so choose whatever you
    use now and include the output in your LaTeX document.
    </p>

    <br/>

    <p>
    Now that we have our recipe, it's time for some notable substitutions
    </p>

    <h5>Substitute for 1: Markdown<sup>5</sup></h5>
    <p>
    An alternative to LaTeX, that I use for taking notes in classes,
    is just Markdown, which renders to html and other formats through
    many tools e.g. pandoc. If you've ever used GitHub, you've probably
    seen rendered Markdown even if you didn't realize it.
    You could also use ReStructured Text or some 
    other similar markup language, so long as there exists some 
    rendering utility for it. 
    </p>
    <p>
    The  most useful things about using Markdown, are definitely
    the effortless
    simplicity of the language (learning it) and the decoupling 
    of styling from content with CSS. This is likely to be the easier
    to use alternative, and you can still be inspired by our embedding
    of Python in LaTeX and use a custom html tag for python embedding.
    It might look like:
    </p>
    <pre class="terminal">
    My Document
    ===========

    &lt;pyexec&gt;
    from operator import mul
    &lt;/pyexec&gt;

    _this is my document_, 
    and I **like** the number &lt;pyeval&gt;mul(5,3)&lt;/pyeval&gt;
    </pre>
    <p>
    Even more interesting, would be to integrate some LaTeX compilation,
    from packages like <a><i>katex</i></a> to embed LaTeX in your markdown
    where you're already embedding Python. 
    At that point I hope you can somehow embed Python in the LaTeX embedded
    in your Markdown without getting hurt, but it would bring together
    the best of all worlds. Programmability (Python), extensibility (PyPI), 
    simplicity (Markdown), and complexity only when you need it (LaTeX).
    </p>

    <h5>Substitution for 2: Other Scripting Language</h5>
    <p>
    Are you the last person on earth, besides myself, who might like Perl?
    Are you twistedly enamored by the parasite that is PHP<sup>6</sup>? 
    Perhaps you're an ES7 &gt; Python person, or maybe you want to add
    the ability to put R's graphs in your document source.
    If you think about it, the same principles of what we're doing 
    currently apply, just hope that templating with your language is 
    as easy to implement as it was for Python.
    </p>
    <pre class="terminal">
    \begin{CppExec}
        //someone (me) should totally do this with Cling
        #include &lt;vector&gt;
        #include &lt;iostream&gt;
        #include &lt;algorithm&gt;
        std::vector&lt;int&gt; ints = {1,7,5,9};
        template&lt;typename T&gt;
        operator&lt;&lt;(std::ostream& os, const std::vector<T>& vec) {
            for (const auto& x : vec) os &lt;&lt; x &lt;&lt; ", ";
        }
        //I'd use R but I've forgotten what little I knew of R
    \end{CppExec}

    \section*{C++ Sucks}

    \pyeval{ std::sort(ints), ints }
    </pre>

    <p>
    And there we go. So you can take this stuff here and make a script
    wrapping around your favorite compiler to evaluate your scripted
    expressions first as part of a compilation pipeline. Or you can see
    If you want to make this a production tool, go prevent
    the string literal end marker issue by ignoring string literals, 
    and research LuaTeX and general TeX packages and extensions to see 
    where a Python evaluation step can be added. I would
    appreciate it certainly. But that's a lot of work and while I'm 
    the only person doing this still, I'll just stick to my &lt;20 lines
    of code that works 99.99% of the time.
    </p>

    <p>
    Oh, and if you don't want to use any of this, 
    go check out Libre/Open Office.
    </p>

    <p>
    Appendix?:
        </p><ol>
            <li>
                <b>1. DSL</b>: domain specific language. 
                Wouldn't it be funny to have a dystopian future 
                where people can only communicate via powerpoints?
            </li>
            <li>
                <b>2. *.docx</b>: The Microsoft Word file format. 
                Some compressed XML if I recall correctly and there used 
                to be a .doc format too. 
            </li>
            <li>
                <b>3. You will end up using MS Office</b>: Growing up is learning
                that you will have to give up and use MS Office.
            </li>
            <li>
                <b>4. LuaTeX</b>: An extensible TeX compiler. I haven't
                looked into it much but it is likely the best candidate for
                embedding Python in the TeX compilation process. Though it's
                likely easier to embed Lua, one might think. 
            </li>
            <li>
                <b>5. Markdown</b>: Proof that no one who writes blogposts should be writing pure HTML like I am currently. How can I even tolerate writing out ampersand literals...
            </li>
            <li>
                <b>6. PHP</b>: As much as I laugh at PHP, 
                <a href="">read the rant</a>, it's probably the easiest 
                to do templating with since that's part
                of the design of the language. Although have fun using it
                in LaTeX.
            </li>
        </ol>
    <p></p>


</div>
<style>
.blog {
    text-align: left;
}
</style>
