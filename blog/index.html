<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/styles.2776c9e68fdab033495f.css">._3d-module--container--3u9YK{display:flex;flex-wrap:wrap}._3d-module--container--3u9YK img{max-height:200px}.work-module--container--31LKz{overflow:hidden}.work-module--pdf--8cbUT{width:100%}@media only screen and (max-width:700px){.header-module--pageWrapper--1ij_0{padding:12px}}@media only screen and (min-width:700px){.header-module--pageWrapper--1ij_0{padding:22px 1in 1in}}.header-module--separate--G80zA{display:flex;align-items:center;justify-content:space-between}.header-module--separate--G80zA .header-module--left--2-ITV{display:flex;flex-direction:row;flex-wrap:wrap;margin-left:-22px;padding:11px}.header-module--separate--G80zA .header-module--left--2-ITV .header-module--navLink--1IuEZ{margin:11px}.header-module--separate--G80zA .header-module--left--2-ITV .header-module--navLink--1IuEZ,.header-module--separate--G80zA .header-module--left--2-ITV .header-module--navLink--1IuEZ:link,.header-module--separate--G80zA .header-module--left--2-ITV .header-module--navLink--1IuEZ:visited{font-size:2rem;color:rgb(var(--body-rgb));text-decoration:initial;font-style:italic;font-weight:700;-webkit-transition:font-size .1s ease;transition:font-size .1s ease;height:2.5rem;vertical-align:middle}@media only screen and (max-width:700px){.header-module--separate--G80zA .header-module--left--2-ITV .header-module--navLink--1IuEZ,.header-module--separate--G80zA .header-module--left--2-ITV .header-module--navLink--1IuEZ:link,.header-module--separate--G80zA .header-module--left--2-ITV .header-module--navLink--1IuEZ:visited{font-size:1.5rem}}.header-module--separate--G80zA .header-module--left--2-ITV .header-module--navLink--1IuEZ:hover{color:orange;font-size:2.5em}@media only screen and (max-width:700px){.layout-module--pageWrapper--22gEu{padding:12px}}@media only screen and (min-width:700px){.layout-module--pageWrapper--22gEu{padding:22px 1in 1in}}body{margin:0;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;background-color:rgb(var(--background-rgb));color:rgb(var(--body-rgb))}code{font-family:source-code-pro,Menlo,Monaco,Consolas,Courier New,monospace}a{color:#49a9f9}a:visited{color:#69a9f9}a:active{color:#b9b999}h1{font-size:1.4em;font-weight:700}h1,h3{font-style:italic}h3{font-size:1em;font-weight:400}h1+h3{margin-top:-8px}hr{color:rgba(var(--body-rgb),.3)}:root{--background-rgb:18,18,24;--body-rgb:239,239,239}.blog-module--container--1AB_S{display:flex;flex-direction:column}@-webkit-keyframes blog-module--spin--1qXz7{0%{-webkit-transform:scaleX(0);transform:scaleX(0)}50%{-webkit-transform:scaleX(1);transform:scaleX(1)}to{-webkit-transform:scaleX(0);transform:scaleX(0)}}@keyframes blog-module--spin--1qXz7{0%{-webkit-transform:scaleX(0);transform:scaleX(0)}50%{-webkit-transform:scaleX(1);transform:scaleX(1)}to{-webkit-transform:scaleX(0);transform:scaleX(0)}}.blog-module--loader--2rIeb{display:flex;align-items:center;justify-content:center}.blog-module--loader--2rIeb .blog-module--inner--7Iy55{border:4px solid rgb(var(--body-rgb));height:26px;width:26px;border-radius:50%;-webkit-animation-name:blog-module--spin--1qXz7;animation-name:blog-module--spin--1qXz7;-webkit-animation-duration:1s;animation-duration:1s;-webkit-animation-iteration-count:infinite;animation-iteration-count:infinite;-webkit-animation-timing-function:ease-out;animation-timing-function:ease-out}.blog-module--post--1jMia{width:100%}</style><meta name="generator" content="Gatsby 2.18.4"/><title data-react-helmet="true">Blog | Mike Belousov&#x27;s Website</title><link data-react-helmet="true" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/a11y-dark.min.css" integrity="sha256-7L/IK7qUTcgTXtfLAxip5Eo+hnp+pSe5htBCh5pYg6o=" crossorigin="anonymous"/><meta data-react-helmet="true" name="description" content="See title"/><meta data-react-helmet="true" property="og:title" content="Blog"/><meta data-react-helmet="true" property="og:description" content="See title"/><meta data-react-helmet="true" property="og:type" content="website"/><meta data-react-helmet="true" name="twitter:card" content="summary"/><meta data-react-helmet="true" name="twitter:creator" content="Mike Belousov"/><meta data-react-helmet="true" name="twitter:title" content="Blog"/><meta data-react-helmet="true" name="twitter:description" content="See title"/><link rel="icon" href="/icons/icon-48x48.png?v=d9516c3b1aedfe7813fb0a8386318dff"/><link rel="manifest" href="/manifest.webmanifest"/><meta name="theme-color" content="#663399"/><link rel="apple-touch-icon" sizes="48x48" href="/icons/icon-48x48.png?v=d9516c3b1aedfe7813fb0a8386318dff"/><link rel="apple-touch-icon" sizes="72x72" href="/icons/icon-72x72.png?v=d9516c3b1aedfe7813fb0a8386318dff"/><link rel="apple-touch-icon" sizes="96x96" href="/icons/icon-96x96.png?v=d9516c3b1aedfe7813fb0a8386318dff"/><link rel="apple-touch-icon" sizes="144x144" href="/icons/icon-144x144.png?v=d9516c3b1aedfe7813fb0a8386318dff"/><link rel="apple-touch-icon" sizes="192x192" href="/icons/icon-192x192.png?v=d9516c3b1aedfe7813fb0a8386318dff"/><link rel="apple-touch-icon" sizes="256x256" href="/icons/icon-256x256.png?v=d9516c3b1aedfe7813fb0a8386318dff"/><link rel="apple-touch-icon" sizes="384x384" href="/icons/icon-384x384.png?v=d9516c3b1aedfe7813fb0a8386318dff"/><link rel="apple-touch-icon" sizes="512x512" href="/icons/icon-512x512.png?v=d9516c3b1aedfe7813fb0a8386318dff"/><link as="script" rel="preload" href="/webpack-runtime-ca7044d80c9df38a8d05.js"/><link as="script" rel="preload" href="/app-f5b5ca7c21ff7033894d.js"/><link as="script" rel="preload" href="/styles-3a292b7fca9ed6b2fd45.js"/><link as="script" rel="preload" href="/commons-7afd17c9e0c8c9e90571.js"/><link as="script" rel="preload" href="/component---src-pages-blog-tsx-09661ba69094cee817f9.js"/><link as="fetch" rel="preload" href="/page-data/blog/page-data.json" crossorigin="anonymous"/></head><body><noscript id="gatsby-noscript">This app works best with JavaScript enabled.</noscript><div id="___gatsby"><div style="outline:none" tabindex="-1" role="group" id="gatsby-focus-wrapper"><div class="layout-module--pageWrapper--22gEu"><header><div class="header-module--separate--G80zA"><div class="header-module--left--2-ITV"><a class="header-module--navLink--1IuEZ" href="/">Home</a><a class="header-module--navLink--1IuEZ" href="/work">Work</a><a class="header-module--navLink--1IuEZ" href="/3d">3D</a><a class="header-module--navLink--1IuEZ" href="/blog">Blog</a></div><div><h1>Mike Belousov</h1></div></div><hr/></header><main><div class="blog-module--post--1jMia"><h1>Photoshop is no longer my sketch pad</h1><h3>July 13, 2019</h3><div><p>I needed to do a top-down draft, a design of something I would be 3D-modeling later, and so I opened up
my 2D drawing toolkit. Once photoshop, it was actually more recently Krita. I bumped the resolution to
5000x5000 pixels, and had to think deeply about it.</p>
<p>The lack of dynamic resolution is so saddening
in my drafting process. Having to worry about blurry details and zooming in too far, or zooming out too
far, causing slow stroke finalization/rendering. So, using Blender for practically everything else and
loving Blender 2.8 recently, I decided to check out its new 2D tools for kicks. Lo and behold, the lagless
vector-based, infinite resolution, hassle-free zoom, layered, materialed, simple, beautiful 2D workspace of my
dreams was before me. Gone are the days of drawing arrows to various scene elements to elaborate on them.
Just zoom into them! You can just zoom infinitely and write inside them. The brushes are clean, and
customizable. Erasing is instant (use point-erase), and rendering is lagless. And since you're not
dealing with raster, there are <em>no</em> complex selections to perform. You can select strokes independently,
select their points, move things, scale things, and it takes no time at all. You can <em>sculpt</em> your points,
adding or reducing thickness of lines, moving them, adding some fuzziness, simplifying them, and more. It's not
just good for drafting, but all drawing comes naturally to it. And you can even extend it to 3D! Draw in 3D,
start modeling in 3D. Draw on your 3D models to concept some greebling if your artstyle demands it!
It has never felt so easy to me. Blender has always been good for what it does,
but it has never felt so exceptionally designed until now. Whether you're designing interfaces or levels, doing
3D graphics work, doing 2D work, or any animation, definitely get into Blender 2.8 and start a new 2D drawing
project. It just works!</p></div><hr/></div><div class="blog-module--post--1jMia"><h1>Photoshop is no longer my sketch pad</h1><h3>May 04, 2019</h3><div><p>For my computational geometry course, I and a small team of my pears wrote a
visualization comparing the naive and the Melkman convex hull
finding algorithms, with some pedagogical narration, it
was a fun opportunity to really learn Elm for HTML5 content authoring, and SVG rendering.
<a href="https://mikemikeb.com/convex-hull-visualization/">See it here</a>.</p>
<p>The narration needs some work, the style is pretty poor and there's no mobile support,
so I'll come back to polish it some night. Especially since I learned CSS properly since.</p></div><hr/></div><div class="blog-module--post--1jMia"><h1>Empowering LaTeX (PyLaTeXc)</h1><h3>May 04, 2019</h3><div><p>The one nagging gap in my homework development stack early on
was an itch for
programmability, that trait which Excel is alleged to have.
But I have a gripe with Excel. It's like Scratch for adults,
A psuedoscripting language for the uninitiated and unlearned.
Personally, I've always kicked up a Python interpreter any
time I needed a calculation, and I quickly began depending on
Python+scipy for more intense derivations and data routines. I scratched
up a utility module for producing LaT<sub>E</sub>X tables and pgfplots graphics
from various data formats, and used it frequently with minimal
copy and paste glue (thank you Cygwin's
<code>/dev/clipboard</code>).</p>
<p>But larger projects begged for more complete tools; like that assignment
involving the visualization
of 26 different samples from a dataset, as well as calculating some
statistical metrics about each sample.
A sane person would have used the charting features
in the Excel spreadsheet it was provided in, but that's outside the scope
of this post.
I exported to csv immediately and made an incredibly primitive
toolkit for embedding Python logic in LaT<sub>E</sub>X. Revisiting it a
couple of months later, I refined my toolkit massively and today I
would consider the design complete, but alternative implementation
approaches merit some exploration.</p>
<p>The first time I attemped glueing my Pythonisms into LaT<sub>E</sub>X,
my design was a tiny mapping from a LaT<sub>E</sub>X grammar extension
to Python formatting key syntax.
If I were to write my LaT<sub>E</sub>X code directly in a Python string,
and attempt to use formatting keys,
I would probably spontaneously combust. It looks like this:</p>
<pre><code class="language-python">r"""\begin{{document}}
\frac{{ {kill} }}{{ {me} }}
\end{{document}}""".format(kill=5, me=10)
</code></pre>
<p>That's almost as crufty as chained ternary expressions in JSX.
Backslash doubling I can avoid by making it a raw string, but that
isn't an option in all use cases.
Regardless, I hid this formatting ugliness behind a script, which
escaped braces for me, and interpretted the characters '&#x3C;&#x3C;' as '{', and
'>>' as '}'. So now I didn't have to brace every 5 characters, and the
keys looked distinct from the LaT<sub>E</sub>X syntax.
My dumb and ugly LaT<sub>E</sub>X superset templater took about 5 lines of
Python code to process, and the source looked like:</p>
<pre><code class="language-python">\begin{document}
\frac{&#x3C;&#x3C;numerator>>}{&#x3C;&#x3C;denominator>>}
\end{document}
</code></pre>
<p>Quite literally, all my template processor had to do was replace all braces with
escaped double braces, and then replace all
double angle brackets with a single formatting brace, thus yielding
the valid Python formatting keys, while allowing raw LaT<sub>E</sub>X to look
at least familiar.
Then you just produce your values and/or data in your Python script,
read this template from some file,
and submit it to Python's formatting functinos with the expected keyword
arguments that you used in the document source
(e.g. &#x3C;<numerator>>).
Here's the naive templating implementation:</p>
<pre><code class="language-python">def load_pytex(path, **kwargs):
  txt = open(path).read()
  txt = txt.replace('{','{{').replace('}','}}')    
  txt = txt.replace('&#x3C;&#x3C;', '{').replace('>>', '}')
  txt.format(**kwargs)
  return txt  # or subproc.check_output(['pdflatex' ...])
</code></pre>
<p>So this works, but it would be quite annoying to have a Python
context so decoupled from the usage context. Calculating things
without regard to the location in the document, and being
unable to change the logic while editing the document without
switching files.
Certainly I could do better? So I did something sinful.</p>
<p>Fake macros in LaT<sub>E</sub>X will make this all look way more T<sub>E</sub>X-savvy.
Let's add a <code>\pyeval</code> pseudo-command, and a
<code>pyexec</code> pseudo-environment so that we can get something
like so:</p>
<pre><code class="language-python">\begin{pyexec}
name = 'John'
\end{pyexec}

Hello I am \pyeval{' '.join([name,'Smith'])}
</code></pre>
<p>Originally I implemented (knowing my transgressions) a naive
regular expression based implementation, but this has many problems</p>
<ul>
<li>I want to ignore false ends in quotes and comments</li>
<li>I want to allow counting of nested braces in pyeval</li>
</ul>
<p>expressions so that you don't need to escape all right
braces. (Regular expressions can't find the valid ending
brace of a nested expression)
Checkout the following counter_examples:</p>
<pre><code class="language-python">\begin{pyexec}
hate_you = r'\end{pyexec}'  # we need to avoid ending if its in a literal
\end{pyexec}

\pyeval{h = {'hello': 'world', 'x': {}}}  # which brace do we end on?
</code></pre>
<p>So I couldn't use regular expressions for this, but I still wanted it.
Because my LaT<sub>E</sub>X document source would look like this:</p>
<pre><code class="language-python">\begin{pyexec}
from scipy.optimize import curve_fit
from random import random as rand
from itertools import count, product as crossproduct
bin = crossproduct((0,1),repeat=5)
data = list(zip(count(), bin))
# add a count of set bits as a column
for row in data:
d, b = row
row.append(b.count(1))
randpts = [[rand(),rand()] for _ in range(100)]
\end{pyexec}

\section*{Data Stuff}

\begin{tabular}{|c|c|}
\hline
Decimal &#x26;amp; Binary &#x26;amp; 1-Bits \\
\hline
\pyeval{'\n'.join(('&#x26;amp;'.join(map(str,d)) for d in data))}
% we can extract the above one-liner for reuse in tabular 
% construction and any horizontally partitioned context
\hline
\end{tabular}

% use unpack+zip hack to get separate lists of x then y coords
Best Fit: \pyeval{curve_fit(lambda x,m,b: m*x+b, zip(*randpts))} 
</code></pre>
<p>Mmmmm... delicious. It looks so much like Python yet so much like LaT<sub>E</sub>X.
It's both at once, without crippling either one! It's logic embedded in the document
markup cleanly. So I did go and implement it. Originally I tried using a more
complicated parsing approach, PyParsing, but it turned out to be far too complicated
for what was essentially templating. I ended up settling on parsing by character, due
to the simplicity of the extension. There are a few performance enhancements I could
make but I'm not in the need of them right now, and I've noted them for posterity in
my README. This is PyLaT<sub>E</sub>X, and I put it on my
<a href="https://github.com/MichaelBelousov/pylatexc">GitHub</a></p>
<p>At last, I would argue, that we have a tool more extensible than Excel,
it's got all of PyPI behind it, with numpy, scipy, and all the packages
you could want&#x26;emdash; embedded in your document.
If you like this approach, maybe you can be just as sinful and throw it into
Markdown, or change up the scripting language to your preference. So long as you
don't use php. Even if it's already a templating language.</p>
<pre><code class="language-markdown">My Document
===========

```pyexec
import csv
data = list(csv.reader('mycsv.csv'))
```
`>>> '\n'.join(data)`
</code></pre>
<p>And as a final note, check out <a href="https://typora.io/">Typora</a>
other cool ways to not use Office products. I don't actually use it, but the LaT<sub>E</sub>X
in Markdown makes me want to. Even if I'm not in school any more.</p>
<style>
span.vim {
    font-size: 3pt;
}
</style></div><hr/></div><div class="blog-module--post--1jMia"><h1>Bill Wurtz</h1><h3>August 28, 2018</h3><div><p>Shout-out to Bill Wurtz.</p>
<p>His website is a real treat, it harkens back to the early web styles (or lack thereof). It reminds me of a simpler time when websites were awesome.</p>
<p>Check it out: <a href="https://billwurtz.com">billwurtz.com</a></p></div><hr/></div><div class="blog-module--post--1jMia"><h1>Super Thin RAII Wrappers for C Types</h1><h3>June 17, 2018</h3><div><p>Let's partake in some template indulgence. Suppose we have some C language
library that we're linking to our amazing C++ project, but it leaves us with
a few sad C "constructors" and "deleters" surrounding a struct, like any
non-object-oriented language. Suppose we have a struct: <code>struct MyCType</code>,<br>
a "constructor" for it: <code>MyCtype* Create_MyCType()</code> and a "deleter"
for it too: <code>Free_MyCType(MyCType*)</code>.</p>
<p>If you don't know what
<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">Resource Acquisition is Initialization</a>
is, you should check it out, it's a useful programming idiom, often associated with C++,
that you probably already use somewhere.
So the question is, how can we get ourselves some nice RAII, scope-based destruction
for this type with minimal boiler plate? </p>
<p>Our goal is that we can transform this code:</p>
<pre><code class="language-cpp">void myFunc()
{
  CType* ctype = initialize_CType();
  //do something with c type
  destroy_CType(ctype);
}
</code></pre>
<p>Into this code:</p>
<pre><code class="language-cpp">void myFunc()
{
    WrappedCType type;
    //do something with it
}
</code></pre>
<p>Isn't that much cleaner?
I'll look into using the STL for a great, simple solution, and then a custom
wrapper emphasizing performance.</p>
<p>Indeed, it turns out we can actually do what we want there
<em>very</em> easily, having decent knowledge of the STL, the natural solution to the
problems that most over-zealous c++ programmers have.
Let's give this an STL solution before we look into a custom one and later we'll
see what kind of performance gains we can find and if it's worth it.
But first, let's define some contrived "C code", structs and functions that we
will attempt to wrap. We'll assume it's partitioned into headers and implementation
source as the files in our working directory of "ctype.h" and "ctype.c".</p>
<pre><code class="language-cpp">// === ctype.h =============

typedef struct {
  int s;
  unsigned long long t;
} ExampleSubType;

typedef struct {
  int a;
  float b;
  ExampleSubType* sub;
} ExampleCType;

// === ctype.c ============

ExampleCType* Create_ExampleCType(int i, float f)
{
  //pardon any mistakes, in my tests I used C++ allocation
  //i.e. new ExampleCType{i,f, new ExampleSubType{5, ...}};
  ExampleCType* result = malloc(sizeof(ExampleCType));
  result->a = i;
  result->b = f;
  result->sub = malloc(sizeof(ExampleSubType));
  result->sub->s = 5;
  result->sub->t = 334323464592ULL;
  return result;
}

void Free_ExampleCType(ExampleCType* in)
{
  free(in->sub);
  free(in);
}
</code></pre>
<p>So, how can we elegantly use the STL To initialize with our Create function,
and destroy with our Delete function? The real hint should be our intended scope
based destruction. We can provide a smart pointer with a custom deleter, which
happens to match our intended signature. If it didn't, we could still probably use
a fitting lambda expression to map it to the required deleter signature. Let's do it
as follows:</p>
<pre><code class="language-cpp">#include &#x3C;ctype.h>
#include &#x3C;type_traits>
#include &#x3C;memory>
#include &#x3C;iostream>
using namespace std;  //for brevity and tersity

template&#x3C;auto Create, auto Delete, typename... CreateArgTypes>
shared_ptr&#x3C;
typename remove_pointer&#x3C;
decltype(Create(declval&#x3C;CreateArgTypes>()...))>::type>
makeCTypeWrapper(CreateArgTypes&#x26;&#x26;... args)
{
  using CTypePtr = decltype(Create(declval&#x3C;CreateArgTypes>()...));
  using CType = typename remove_pointer&#x3C;CTypePtr>::type;
  return shared_ptr&#x3C;CType>(Create(args...), Delete);
}

int main()
{
  //Example example_inst{1, 0.5f};
  auto example_inst = makeCTypeWrapper&#x3C;
  Create_ExampleCType,
    Free_ExampleCType>
  (-5, 0.5f);
  cout &#x3C;&#x3C; "peek at the instance's 'a' member" &#x3C;&#x3C; endl;
  cout &#x3C;&#x3C; example_inst->a &#x3C;&#x3C; endl;
  cout &#x3C;&#x3C; "peek at the instance's 'sub' member's 't' member" &#x3C;&#x3C; endl;
  cout &#x3C;&#x3C; example_inst->sub->t &#x3C;&#x3C; endl;
}
</code></pre>
<p>This has some awesome advantages. Copy prevention (if you use unique<em>ptr),
reference counting, all the things that come with smart pointers. The one
issue is, what if the library you're using already does reference counting?
What if this is just too much overhead for what you're doing? Exploring a
more raw wrapper is the next step, but before that, I'll first show what would
make a lovely addition to the above code... if C++ allowed deduced arguments for
templated aliases. Using a function pointer variable type alias, we can craft
a single, make</em>Example() function with no template parameters. Unfortunately, without
deduction, you would have to explicitly list the argument types which is ugly
and worst of all redundant. Either way, it might look something like this:</p>
<pre><code class="language-cpp">template&#x3C;typename... ArgTypes>
shared_ptr&#x3C;ExampleCType>(*make_Example(ArgTypes...) = 
    &#x26;makeCTypeWrapper&#x3C;Create_ExampleCtype, Free_ExmapleCType, ArgTypes...>;
</code></pre>
<p>So then, we're on to a raw wrapper. How thin can we make it?
Can we make the wrapping inlined by the compiler entirely? I will explore the latter
question and discuss it in another article. For now we'll just bring the wrapper into
existence. That question is what I'd like to use to determine if the
smart_pointer solution is worth it in performance-critical contexts.</p>
<p>We'll start with the idea for our template that hopefully will inevitably do everything
we want.</p>
<pre><code class="language-cpp">template&#x3C;typename CType, CType*(Create*)(), void(Free*)(CType*)>
struct CTypeWrapper;
</code></pre>
<p>We've got function pointer type value arguments to our template already, and later
we'll add variadic arguments to match any signature for the Create function. This
could be used to match different overloads but unfortunately it seems difficult to
infer the overload so we can't do much without boilerplate as far as my
intelligence falls.
We can at least infer the wrapped type itself from the function pointer arguments.
For now let's put in a simple implementation and see how it compiles.</p>
<p>I ended up adding some additional templated aliases for the function pointer
types, which makes it much more comprehensible, but these will disappear in the
C++17 version.</p>
<pre><code class="language-cpp">template&#x3C;T>
using CreateFunc = T*(*)();

template&#x3C;T>
using FreeFunc = void(*)(T*);

template&#x3C;typename CType, 
  CreateFunc&#x3C;CType&#x3C; Create, 
  FreeFunc&#x3C;CType&#x3C; Free&#x3C;
struct CTypeWrapper
{
  CType* wrapped;
  CTypeWrapper()
    : wrapped(Create())
  {}
  ~CTypeWrapper()
  {
    Free(wrapped);
  }
  //implicit conversion to wrapped type
  operator CType* ()
  {
    return wrapped;
  }
  CType* operator->()
  {
    return wrapped;
  }
};
</code></pre>
<!--

I should probably say by now that there will be some elements of danger
to stuff I am discussing, but one of the cool things (I think) you can do
with this type is safely cast a reference of it to the underlying pointer.

-->
<p>Now let's use our contrived C example and see what happens</p>
<pre><code class="language-cpp">#include"ctype.h"
#include"CTypeWrapper.h"
#include &#x3C;iostream>

using namespace std;  //for brevity and tersity
//our shiny type wrapper
using Example = CTypeWrapper&#x3C;ExampleCType, 
      Create_ExampleCType, 
      Free_ExampleCType>;

int main()
{
  Example example_inst;
  cout &#x3C;&#x3C; "peek at the instance's 'a' member" &#x3C;&#x3C; endl;
  cout &#x3C;&#x3C; example_inst->a &#x3C;&#x3C; endl;
  cout &#x3C;&#x3C; "peek at the instance's 'sub' member's 't' member" &#x3C;&#x3C; endl;
  cout &#x3C;&#x3C; example_inst->sub->t &#x3C;&#x3C; endl;
}
</code></pre>
<p>Assuming "CTypeWrapper.h" contains our templates we've made, we should be good
to go. Our output is:</p>
<pre><code>peek at the instance's 'a' member
100
peek at the instance's 'sub' member's 't' member
334323464592
</code></pre>
<p>So we've got implicit conversion to the underlying type, and an overrided
<code>operator-></code>to
provide access to the underlying type. This should feel a bit worrisome actually,
because our type <em>should</em> feel like a value, not a pointer, but overriding the
<code>.</code>  operator is out of the question for good reason and the
<code>-></code> syntax reminds us that our type really just contains an underlying
pointer so in my opinion it's, <em>ok</em>, not great. Definitely sinful.</p>
<p>I tried with some difficulty to find out how one can template alias the type
to provide a variadic constructor, but unfortunately I don't believe it's possible
since the first two types cannot be deduced in a class construction context
and template aliases can't either (as far as I know up to c++17). The function
deduction context appears to correctly deduce the types even with only the partial
explicit template parameters, but the class doesn't seem to be able to. I couldn't
figure out a deduction guideline for it either, but I will
look into the difference in deduction rules for classes and functions, and confirm
or fix my loss here.
This minimal and I think "acceptable" boilerplate is the
farthest I got for generic RAII wrappers of C-style types. If you're looking to C++-ify
your C-using code, try something like this, but clearly a heavy duty careful wrapper is
the real solution to any sufficient project. There are a few more hacks for quick wrapping
of C types that I explored and may revisit later, but for now I'll leave the code where
I left off, with a tidy wrapper which unfortunately has some definition boilterplate.</p>
<pre><code class="language-cpp">#include "ctype.h"
#include &#x3C;type_traits>

template&#x3C;
auto Create, 
     auto Free,
     typename... CreateArgTypes>
struct CTypeWrapper
{
  private:
    using CTypePtr = decltype(Create(std::declval&#x3C;CreateArgTypes>()...));
  public:
    CTypePtr wrapped;
    CTypeWrapper(CreateArgTypes&#x26;&#x26;... args)
      : wrapped{Create(args...)}
    {}
    ~CTypeWrapper()
    {
      Free(wrapped);
    }
    operator CTypePtr ()
    {
      return wrapped;
    }
    CTypePtr operator->()
    {
      return wrapped;
    }
};

using Example = CTypeWrapper&#x3C;
Create_ExampleCType, 
  Free_ExampleCType, 
  int, double>;

#include &#x3C;iostream>
using namespace std;  //for brevity and tersity

int main()
{
  //Example example_inst{1, 0.5f};
  Example example_inst{-5, 0.5f};
  cout &#x3C;&#x3C; "peek at the instance's 'a' member" &#x3C;&#x3C; endl;
  cout &#x3C;&#x3C; example_inst->a &#x3C;&#x3C; endl;
  cout &#x3C;&#x3C; "peek at the instance's 'sub' member's 't' member" &#x3C;&#x3C; endl;
  cout &#x3C;&#x3C; example_inst->sub->t &#x3C;&#x3C; endl;
}
</code></pre>
<p>I'll add a follow up article eventually for analyzing some of the
llvm-ir assembly instructions that the clang compiler can emit to get a good idea
at the overhead the wrapper incurs and how to minimize it or potentially eradicate
it with optimization
and inlining. If you find better ways, as I'm sure you will, please inform me!</p></div><hr/></div></main></div></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/blog/";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"app":["/app-f5b5ca7c21ff7033894d.js"],"component---src-pages-3-d-tsx":["/component---src-pages-3-d-tsx-0b25d30a45cbce9008f9.js"],"component---src-pages-404-tsx":["/component---src-pages-404-tsx-248cd168b95cf1cba85f.js"],"component---src-pages-blog-tsx":["/component---src-pages-blog-tsx-09661ba69094cee817f9.js"],"component---src-pages-index-tsx":["/component---src-pages-index-tsx-2ef32bfc7a501412473c.js"],"component---src-pages-work-tsx":["/component---src-pages-work-tsx-d5d27a3748025b50534d.js"]};/*]]>*/</script><script src="/component---src-pages-blog-tsx-09661ba69094cee817f9.js" async=""></script><script src="/commons-7afd17c9e0c8c9e90571.js" async=""></script><script src="/styles-3a292b7fca9ed6b2fd45.js" async=""></script><script src="/app-f5b5ca7c21ff7033894d.js" async=""></script><script src="/webpack-runtime-ca7044d80c9df38a8d05.js" async=""></script></body></html>