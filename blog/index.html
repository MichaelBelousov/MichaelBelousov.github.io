<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/styles.395d2f2b53e58e75ebc8.css">._3d-module--container--3u9YK{display:flex;flex-wrap:wrap}._3d-module--container--3u9YK img{max-height:200px}.work-module--container--31LKz{overflow:hidden}.work-module--pdf--8cbUT{width:100%}@media only screen and (max-width:700px){.header-module--pageWrapper--1ij_0{padding:12px}}@media only screen and (min-width:700px){.header-module--pageWrapper--1ij_0{padding:22px 1in 1in}}.header-module--separate--G80zA{display:flex;align-items:center;justify-content:space-between}.header-module--separate--G80zA .header-module--left--2-ITV{display:flex;flex-direction:row;flex-wrap:wrap;margin-left:-22px;padding:11px}.header-module--separate--G80zA .header-module--left--2-ITV .header-module--navLink--1IuEZ{margin:11px}.header-module--separate--G80zA .header-module--left--2-ITV .header-module--navLink--1IuEZ,.header-module--separate--G80zA .header-module--left--2-ITV .header-module--navLink--1IuEZ:link,.header-module--separate--G80zA .header-module--left--2-ITV .header-module--navLink--1IuEZ:visited{font-size:2rem;color:rgb(var(--body-rgb));text-decoration:initial;font-style:italic;font-weight:700;transition:font-size .1s ease;height:2.5rem;vertical-align:middle}@media only screen and (max-width:700px){.header-module--separate--G80zA .header-module--left--2-ITV .header-module--navLink--1IuEZ,.header-module--separate--G80zA .header-module--left--2-ITV .header-module--navLink--1IuEZ:link,.header-module--separate--G80zA .header-module--left--2-ITV .header-module--navLink--1IuEZ:visited{font-size:1.5rem}}.header-module--separate--G80zA .header-module--left--2-ITV .header-module--navLink--1IuEZ:hover{color:orange;font-size:2.5em}@media only screen and (max-width:700px){.layout-module--pageWrapper--22gEu{padding:12px}}@media only screen and (min-width:700px){.layout-module--pageWrapper--22gEu{padding:22px 1in 1in}}body{margin:0;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;background-color:rgb(var(--background-rgb));color:rgb(var(--body-rgb))}code{font-family:source-code-pro,Menlo,Monaco,Consolas,Courier New,monospace}a{color:#49a9f9}a:visited{color:#69a9f9}a:active{color:#b9b999}h1{font-size:1.4em;font-weight:700}h1,h3{font-style:italic}h3{font-size:1em;font-weight:400}h1+h3{margin-top:-8px}hr{color:rgba(var(--body-rgb),.3)}:root{--background-rgb:18,18,24;--body-rgb:239,239,239}.blog-module--container--1AB_S{display:flex;flex-direction:column}@keyframes blog-module--spin--1qXz7{0%{transform:scaleX(0)}50%{transform:scaleX(1)}to{transform:scaleX(0)}}.blog-module--loader--2rIeb{display:flex;align-items:center;justify-content:center}.blog-module--loader--2rIeb .blog-module--inner--7Iy55{border:4px solid rgb(var(--body-rgb));height:26px;width:26px;border-radius:50%;animation-name:blog-module--spin--1qXz7;animation-duration:1s;animation-iteration-count:infinite;animation-timing-function:ease-out}.blog-module--post--1jMia{width:100%}</style><meta name="generator" content="Gatsby 2.21.13"/><title data-react-helmet="true">Blog | Mike Belousov&#x27;s Website</title><link data-react-helmet="true" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/a11y-dark.min.css" integrity="sha256-7L/IK7qUTcgTXtfLAxip5Eo+hnp+pSe5htBCh5pYg6o=" crossorigin="anonymous"/><meta data-react-helmet="true" name="description" content="See title"/><meta data-react-helmet="true" property="og:title" content="Blog"/><meta data-react-helmet="true" property="og:description" content="See title"/><meta data-react-helmet="true" property="og:type" content="website"/><meta data-react-helmet="true" name="twitter:card" content="summary"/><meta data-react-helmet="true" name="twitter:creator" content="Mike Belousov"/><meta data-react-helmet="true" name="twitter:title" content="Blog"/><meta data-react-helmet="true" name="twitter:description" content="See title"/><link rel="icon" href="/favicon-32x32.png?v=bdc2871edacbda8dd5a11f8bfaedcd63"/><link rel="manifest" href="/manifest.webmanifest"/><meta name="theme-color" content="#663399"/><link rel="apple-touch-icon" sizes="48x48" href="/icons/icon-48x48.png?v=bdc2871edacbda8dd5a11f8bfaedcd63"/><link rel="apple-touch-icon" sizes="72x72" href="/icons/icon-72x72.png?v=bdc2871edacbda8dd5a11f8bfaedcd63"/><link rel="apple-touch-icon" sizes="96x96" href="/icons/icon-96x96.png?v=bdc2871edacbda8dd5a11f8bfaedcd63"/><link rel="apple-touch-icon" sizes="144x144" href="/icons/icon-144x144.png?v=bdc2871edacbda8dd5a11f8bfaedcd63"/><link rel="apple-touch-icon" sizes="192x192" href="/icons/icon-192x192.png?v=bdc2871edacbda8dd5a11f8bfaedcd63"/><link rel="apple-touch-icon" sizes="256x256" href="/icons/icon-256x256.png?v=bdc2871edacbda8dd5a11f8bfaedcd63"/><link rel="apple-touch-icon" sizes="384x384" href="/icons/icon-384x384.png?v=bdc2871edacbda8dd5a11f8bfaedcd63"/><link rel="apple-touch-icon" sizes="512x512" href="/icons/icon-512x512.png?v=bdc2871edacbda8dd5a11f8bfaedcd63"/><link as="script" rel="preload" href="/styles-f12963b3798c232a68f6.js"/><link as="script" rel="preload" href="/component---src-pages-blog-tsx-1ba1cce2f1c8683eda33.js"/><link as="script" rel="preload" href="/commons-c13a4d43faf544c814b7.js"/><link as="script" rel="preload" href="/framework-4f6f95a87e6130d5bbab.js"/><link as="script" rel="preload" href="/app-c4e5362c755ea511c67f.js"/><link as="script" rel="preload" href="/webpack-runtime-eff488184acabec803dc.js"/><link as="fetch" rel="preload" href="/page-data/blog/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="layout-module--pageWrapper--22gEu"><header><div class="header-module--separate--G80zA"><div class="header-module--left--2-ITV"><a class="header-module--navLink--1IuEZ" href="/">Home</a><a class="header-module--navLink--1IuEZ" href="/work">Work</a><a class="header-module--navLink--1IuEZ" href="/3d">3D</a><a class="header-module--navLink--1IuEZ" href="/blog">Blog</a></div><div><h1>Mike Belousov</h1></div></div><hr/></header><main><div class="blog-module--post--1jMia"><h1>React and its hooks without Create React App</h1><h3>May 06, 2020</h3><div><p>So you want to join the <a href="https://reactjs.org">React</a> world, but when you look online,
you either see some buzz about hooks, or a bunch of tutorials using React with big
classes and method overrides. Most of all you probably see something that isn't technically
real Javascript, JSX.
There's an open secret about modern web development. It's complicated. Really complicated.
A-transpiles-to-B-transpiles-to-C-transpiles-to-Javascript complicated (more on the word
<em>transpile</em> later. Maybe this isn't that
secret, but lots of web developers either ignore it or pretend it's easy after learning
50 distinct technologies to make their website. This article will try to take the magic out,
and hopefully show that there is a light at the  end of the tunnel.</p>
<p>JSX is a very small one of those many technologies, a syntax extension for JavaScript that allows
you to declare HTML element trees in code instead of manually manufacturing them. Even
more specifically, JSX
is really syntactic sugar used by the react ecosystem for constructing "components", a
reusable chunk of HTML.
Take for instance the following vanilla JavaScript script running in a simple webpage.
If you want to test it, you can run <code>python3 -m http.server</code> in a folder
containing the two files, then you can see it at localhost:8000 in the browser.</p>
<pre><code class="language-js">// index.js
var people = [{name: 'John', age: 25}, {name: 'Mike', age: 22}];
var root = document.getElementById('root');
var ul = document.createElement('ul');
root.appendChild(ul);

for (var i = 0; i &#x3C; people.length; i++) {
  var li = document.createElement('li');
  li.innerHTML = people[i].name + " is " + people[i].age + " years old";
  ul.appendChild(li);
}

// If you've seen modern JavaScript, you'll notice there are
// some no-nos above, there are better ways to do things now
</code></pre>
<pre><code class="language-html">&#x3C;!DOCTYPE html>
&#x3C;!-- index.html -->
&#x3C;html>
  &#x3C;body>
    &#x3C;div id="root">&#x3C;/div>
  &#x3C;/body>
  &#x3C;script src="/index.js">&#x3C;/script>
&#x3C;/html>
</code></pre>
<p>JSX gives us a much more declarative way to do this:</p>
<pre><code class="language-jsx">var people = [{name: 'John', age: 25}, {name: 'Mike', age: 22}];
// once you know react, you'll know there's something else you need when generating
// a dynamic list of children...
ReactDOM.render(
  &#x3C;ul>
    {people.map(person => &#x3C;li> {person.name} is {person.age} years old &#x3C;/li>)}
  &#x3C;/ul>,
  document.getElementById('root')
);
</code></pre>
<p>But there is one significant difference, JSX is only used in the react ecosystem,
where DOM elements aren't actually built directly by consumers. That's why we need to tell React to run its own
render method given the JSX expression. JSX isn't equivalent to calling the DOM's element construction
API/functions. Even though someone could write a JSX transpiler that did that, it's never seen
wide adoption, probably due to the prevalence of React (You should probably look into
<a href="https://svelte.dev/">Svelte</a> if you're interested in something like that).
If we take what had above and see what the JSX transpiles to, we get the following:</p>
<pre><code class="language-js">React.createElement('ui', null, 
  // the ... "spread" syntax used allows us to generate an arbitrary list of arguments.
  // parameter #3 and beyond to the "React.createElement" function are the children of the element,
  // and can be strings to be an html text node, or another complex element
  ...people.map(p => React.createElement('li',  null, 
    `${p.name} is ${p.age} years old`
  ))
);
</code></pre>
<p>React choosing to not use real elements allows it to have a light-weight representation of the DOM (this technique is called
using a <em>virtual DOM</em> or <em>VDOM</em>) that it can later efficiently update the real DOM to match. If you want
to experiment with more JSX to regular JavaScript conversions, <a href="https://babeljs.io">Babel</a>, the world's de facto JavaScript
transpiler has a <a href="https://babeljs.io/repl/#?browsers=defaults%2C%20not%20ie%2011%2C%20not%20ie_mob%2011&#x26;build=&#x26;builtIns=false&#x26;spec=false&#x26;loose=false&#x26;code_lz=GYVwdgxgLglg9mABACwKYBt1wBQEpEDeAUIogE6pQhlIA8AJjAG4B8AEhlogO5xnr0AhLQD0jVgG4iAXyJA&#x26;debug=false&#x26;forceAllTransforms=false&#x26;shippedProposals=false&#x26;circleciRepo=&#x26;evaluate=false&#x26;fileSize=false&#x26;timeTravel=false&#x26;sourceType=module&#x26;lineWrap=true&#x26;presets=react&#x26;prettier=false&#x26;targets=&#x26;version=7.9.6&#x26;externalPlugins=">playground for JSX compilation</a>.</p>
<p>For your reference, I'll leave here a terse demonstration of all JSX features and differences from HTML.</p>
<pre><code class="language-jsx">//// dynamic children
const selfClosingTag = &#x3C;div />; // all tags can be self closing
const dynamicContent = &#x3C;span> {[selfClosingTag, selfClosingTag]} &#x3C;/span>; 
const lists = &#x3C;span> {[selfClosingTag, selfClosingTag]} &#x3C;/span>; 
const emptyContent = &#x3C;span> {} &#x3C;/span>; 
const objects = &#x3C;span> {"string object"} {5} &#x3C;/span>; 
// this will throw an error, plain objects are not valid react elements
//const emptyContent = &#x3C;span> {{}} {new Date()} &#x3C;/span>; 
const emptyContent = &#x3C;span> {[&#x3C;a href="/link"/>, 5, "hello!"]} &#x3C;/span>; 

const optionalContent = &#x3C;span> {isLoading &#x26;&#x26; &#x3C;Loader/>} &#x3C;/span>;  // clever short-circuiting hacks
// this will throw an error, lower case components CANNOT be user-defined, they're "intrinsic components", defined by HTML
//const loader = &#x3C;myloader />; // won't compile!
const stringProp = &#x3C;MyLoader myCustomStringProp="string" />; // prop is to attribute as component is to element in React
// any object can be passed as a prop by using {} delimiters instead of quotes
const booleanProp = &#x3C;MyLoader myCustomStringProp />; //this is sugar for myCustomStringProp={true}
const numberProp = &#x3C;MyLoader myProp={5} />;
const anyObjectProp = &#x3C;MyLoader myProp={{an: "object"}} />; // prop is to attribute as component is to element in React
// you can spread props
const examplePropObj = {prop1: "value", prop2: 3};
const spreadProps = &#x3C;MyLoader {...examplePropObj} {...{hello: "world"}} />; // just like spreading objects


//// html differences
// use "className" instead of "class"
&#x3C;MyComponent className="my-css-class" />
// listeners on intrinsic elements take real callbacks and are camel-cased
&#x3C;MyComponent onMouseEnter={mouseevent => console.log(mouseevent.target)} />
// inline styles are camel-cased and objects instead of inline css
&#x3C;MyComponent style={{
  marginBottom: "56px",
  marginTop: 0,
}} />
// A react "fragment" generates HTML without needing a parent tag, effectively
// injecting the HTML chunk into the parent element, good for wrapping multiple conditional children
&#x3C;div> {test &#x26;&#x26; &#x3C;>{"hello!"} {5}&#x3C;/>} &#x3C;/div> // if test is true, yields &#x3C;div>hello! 5&#x3C;/div>
// You cannot use XML/HTML comments
//&#x3C;> &#x3C;!-- not valid jsx --> &#x3C;/>
// and you can't always use JS comments which sucks...
// &#x3C;div>
//   // this isn't valid JSX either
// &#x3C;/div>
// usually you can use this if you need a comment:
&#x3C;div> {/* my valid comment */} &#x3C;/div>
</code></pre>
<p>The other main thing React allows, with JSX making it syntactically convenient, is user-defined
"components", they look like normal HTML elements being used in JSX, but they have custom
logic in what attributes (<em>props</em> in React parlance) you can pass them, what
HTML they generate with those attributes, and they can have their own internal state. For example:</p>
<pre><code class="language-jsx">function MyComponent(props) {
  return props.person.age % 2 == 0 ? (
    &#x3C;li> {props.person.name}'s age is divisible by &#x3C;strong>2&#x3C;/strong>! &#x3C;/li>
  ) : (
    &#x3C;li> {props.person.name} is {props.person.age} years old &#x3C;/li>
  );
}

ReactDOM.render(
  &#x3C;MyComponent person={{name: 'Mike', age: 30}} />,
  document.getElementById('root')
);
</code></pre>
<p>That example doesn't actually have state, just to note, but it does generate different
HTML depending on what is passed to it.</p>
<h2>Setting up JSX transpilation without magic</h2>
<p>To <em>transpile</em> is like to compile, but instead of transforming a higher level source language into a lower level language,
it is more indicative of transforming into a similar language. JSX to Javascript, is often called transpilation, probably
because it's done often by Babel which is usually used for real transpilation of converting some JavaScript code into other
JavaScript code using more well-supported features that most browsers will have implemented. As mentioned before, Babel
is the world's most popular JavaScript transpiler. The most popular way to use React is with a tool called <a href="https://github.com/facebook/create-react-app">create-react-app</a>.</p>
<p>But CRA installs about 1500 packages as of today, and uses a <em>bundler</em>, webpack, that manages a transpiler toolchain and hides
the nitty-gritty real stuff from you. You should work without webpack at least once, but I do recommend using webpack for heavy
products and definitely anything in production, so you can get optimization and hot-reloading during development.</p>
<p>Another tool that is thankfully less magical and we will make use of here, is TypeScript. We won't focus on TypeScript much itself, but it will
let us look at the nitty gritty while still developing React comfortably. If you haven't already, now is the time to install <a href="https://nodejs.org">Node.js</a>,
I recommending using a Node installation management program like <a href="https://github.com/nvm-sh/nvm">nvm</a>, or if you're on windows,
<a href="https://github.com/coreybutler/nvm-windows">nvm-windows</a>, to install it. Use it to install a capable version of Node like the following:</p>
<pre><code class="language-bash">nvm install 12.16.3
nvm use 12.16.3
</code></pre>
<p>With node installed, comes its package manager, <code>npm</code>. We could already install <code>create-react-app</code> here, but we're just going to
only install typescript, which will give us the typescript compiler program, <code>tsc</code>. Install it globally (as opposed to the current
directory/project) using <code>npm</code>.</p>
<pre><code class="language-bash">npm install --global typescript
</code></pre>
<p>Now you should be able to run <code>tsc -h</code>, to see some of the options. TypeScript's job for us is not just to compile typescript to JavaScript, but more importantly to
transpile our JSX to React, since it supports JSX in <code>.tsx</code> files. For this article, our goal will be to create a point-buy system
for an RPG character UI. We'll use React with and without hooks, see the difference, and employ some basic css to make it stylish.</p>
<h2>modules</h2>
<p>We will make our React and ReactDOM libraries globals variables in the browser by linking them in the HTML. We will use the
<a href="https://github.com/umdjs/umd">UMD</a> packaged version of React, hosted by
some friendly denizens of the internet <a href="https://www.jsdelivr.com/">jsdelivr</a> which are a Content Delivery Network or CDN, so they host common
files like packaged React builds for us. There are a lot of module formats for JS, but UMD uses a global variable in the browser which makes it
the easiest for us to consume without a bundler like webpack to process it for us.
You can use jsdelivr's search bar to find React, but here's <a href="https://www.jsdelivr.com/package/npm/react?path=umd">a link</a>
directly to their page on provided UMD packages of React. Go ahead and hit the copy clipboard icon and
copy the HTML vesion and load that script in out HTML. It will already be set to the latest stable
version which should be fine. You also need the latest version of <code>react-dom</code> which you can find
using the jsDelivr search bar or <a href="https://www.jsdelivr.com/package/npm/react-dom?path=umd">here</a>.
Your script should look like this, note that both react dependencies are loaded before our site's
own script.</p>
<pre><code class="language-html">&#x3C;!DOCTYPE html>
&#x3C;!-- index.html -->
&#x3C;html>
  &#x3C;head>
  &#x3C;/head>
  &#x3C;body>
    &#x3C;div id="root">&#x3C;/div>
  &#x3C;/body>
  &#x3C;script src="https://cdn.jsdelivr.net/npm/react@16.13.1/umd/react.development.js">&#x3C;/script>
  &#x3C;script src="https://cdn.jsdelivr.net/npm/react-dom@16.13.1/umd/react-dom.development.js">&#x3C;/script>
  &#x3C;script src="/index.js">&#x3C;/script>
&#x3C;/html>
</code></pre>
<p>TypeScript is only designed to really work with packages, so it won't understand yet that we're
expecting React to already exist in global scope. This makes sense, since TypeScript wants to know
the type of everything that is being used, including imported functions. Normally, we'd install the React
package and import it in typescript as such:</p>
<pre><code class="language-tsx">import React from "react";
import ReactDOM from "react-dom";
</code></pre>
<p>Instead, we will simply tell typescript using the <em>declare</em> keyword, that something exists that
it can't tell by itself. We won't go any further into typescript, this will shut up the compiler.</p>
<pre><code class="language-tsx">declare var React: any;
declare var ReactDOM: any;
</code></pre>
<p>This tells typescript that it should expect the names React and ReactDOM were declared using the "var"
keyword somewhere before the code the compiler is processing, and it tells the compiler to not care
about their type by giving them the type, <code>any</code>. We lose valuable typechecking, but it makes
things less complicated to start; we'll still get valuable type checking for our own stuff, but
not when we use the React and ReactDOM names.</p>
<p>Let's get our new <code>index.tsx</code> file off the ground:</p>
<pre><code class="language-tsx">declare var React: any;
declare var ReactDOM: any;

class AttributeCounter extends React.Component {
  constructor() {
    this.state = { value: 10 };
  }
  render() {
    return (
      &#x3C;span>
        {this.props.name}: {this.state.value}
        &#x3C;button>+&#x3C;/button>
        &#x3C;button>-&#x3C;/button> 
      &#x3C;/span>
    );
  }
}

function PointBuy(props) {
  return (
    &#x3C;AttributeCounter name={"Strength"} />
    &#x3C;AttributeCounter name={"Charisma"} />
    &#x3C;AttributeCounter name={"Wisdom"} />
  );
}

ReactDOM.render(
  &#x3C;PointBuy/>,
  document.getElementById('root')
);
</code></pre>
<p>Now run <code>tsc</code> with the <code>--jsx</code> setting set to "react" (it can also not transpile it or target react for iOS). Run it:</p>
<pre><code class="language-bash">tsc --jsx react  index.tsx
</code></pre>
<p>Typescript will create the index.js file for you or yell at you if you made a mistake. You can open it and see some neat tricks, including the converted JSX,
as well as transpilation of other not-well supported javascript features like the class is compiled to a function with a "prototype" property attached to it.
You can read up on prototype based inheritance and JavaScript's object/class model
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">elsewhere</a>,
since that's not in scope here. Either way, you should now
be able to run a server, like the Python simple http server mentioned earlier, navigate to <code>index.html</code> and see React render out 3 values and 3 "+" buttons, and 3 "-" buttons.
With React working, we can talk about state, and what that "useState" function does, and how we're going to use state differently in that class component.</p>
<h2>hooks, class components, and state</h2>
<p>React 16.8 introduced the concept of <em>hooks</em>. React already had what they call <em>functional components</em>, which is where a function takes an object of props as an argument,
and returns a JSX fragment. Hooks allow you to "hook" into React's render logic specific to the currently rendering component. This can be used to identify each component
in the rendered component tree, which means functional components which normally only have access to props can now store their own state in a way unique to the component instance.
With that, you can ditch the use of classes entirely, but we'll come back to this after we learn how to use state the old way in React anyway.</p>
<p>You'll notice we used a class in our <code>index.tsx</code> already. This is the old way of creating stateful components that can rerender themselves. You simply inherit (extend)
the official React.Component class, and override its lifecycle methods, in this case just the "render" method. In these objects, state is an object property of a component instance,
but you can't set it the same way as you normally do in JavaScript. To set state, you need to do it in a way that React knows, so you use the inherited method, <code>setState</code>,
which takes an object containing all of the changed state values. Let's make that "+" button increment the <code>value</code> property of the state.</p>
<pre><code class="language-tsx">class AttributeCounter extends React.Component {
  constructor() {
    this.state = { value: 10 };
  }
  render() {
    return (
      &#x3C;span>
        {this.props.name}: {this.state.value}
        &#x3C;button onClick={() => {
          this.setState({value: this.state.value+1});
        }}>+&#x3C;/button>
        &#x3C;button>-&#x3C;/button> 
      &#x3C;/span>
    );
  }
}
</code></pre>
<p>To do so, we use React's built-in support for setting a listener similiarly to how we would on the DOM, but directly on the component and taking an actual function reference.
On the DOM you'd have to pass a name to a function in scope to the "onclick" attribute, or manually find the element, probably by setting some id attribute, and use the DOM
element API to attach and possibly remove the listener. But here we can just use an arrow function inline to run our component instance's <code>setState</code> method to increment the value.
Next we decrement for the "-" button:</p>
<pre><code class="language-tsx">class AttributeCounter extends React.Component {
  constructor() {
    this.state = { value: 10 };
  }
  render() {
    return (
      &#x3C;span>
        {this.props.name}: {this.state.value}
        &#x3C;button onClick={() => this.setState({value: this.state.value+1})}>+&#x3C;/button>
        &#x3C;button onClick={() => this.setState({value: this.state.value-1})}>-&#x3C;/button>
      &#x3C;/span>
    );
  }
}
</code></pre>
<p>In original React, this was the only way to use state in a way that would cause components to rerender.
The point of React, is that components only rerender when their state changes. This old way isn't bad,
but it's
a lot of boiler plate, and we aren't using any of the life cycle methods at all yet. This works because our component class gives us
a new instance of the component each time React needs one, and we store the state on that component until the component is unmounted by
React and its instance and state variables can be garbage collected.
When we call <code>ReactDOM.render</code>, we give it our React element to render, created by the implicit React.createElement which we're using JSX
to hide. When the react element to be rendered is a class, an instance is initialized, rendered,
and mounted (<em>mounted</em> is React jargon for its resulting render HTML is added to the DOM and
React is keeping track of it).</p>
<p>If you pass a function to <code>React.createElement</code>, React can't create an instance, so it just runs the function with the props object as an argument
from the parent. So two different instances of a functional component use the same function, and have
no state. A functional component used like <code>&#x3C;MyFunction a={5} b={"hello"} c /></code> would be interpreted by React as <code>MyFunction({a: 5, b:"hello", c: true})'</code>. Then
whatever JSX-fragment/React-element that functional component returns is rendered with its components in turn, and any intrinsic elements or strings marked as literal return.
The point is, there is no state this way, just the props passed by the parent.</p>
<p>But we can have state in functional components, when React pays attention to the render order in the tree. Before we start using state in
our functional component using hooks, lets look at where that state is stored, so we can better understand some of the restrictions hooks will
impose.</p>
<p>Suppose we have the following React app:</p>
<pre><code class="language-jsx">import React from "react";
import ReactDOM from "react-dom";

function C() { return "hello"; }

function B(props) {
  return (
    &#x3C;div> &#x3C;C/> {props.b &#x26;&#x26; &#x3C;C/>} &#x3C;/div>
  );
}

class A() {
  constructor() {
    this.state = { a: true };
    setTimeout(() => this.setState({a: false}), 5000); // in 5 seconds make false
  }
  render() {
    return &#x3C;B b={this.state.a}/>;
  }
}

ReactDOM.render(&#x3C;A/>, root);
</code></pre>
<p>So the App is an <code>A</code> component, when A is rendered, it tells React to render one child <code>B</code> with a prop of <code>b</code> as <code>true</code> which is
derived from its state of <code>a</code>. <code>B</code> renders two <code>C</code> components, because its <code>b</code> component as passed to it was true, and the <code>&#x26;&#x26;</code> expression evaluated
via short-circuiting to a <code>B</code> element.</p>
<div style="text-align:center">
  <img style="width:600px" alt="YOU CAN'T SEE THIS IMAGE" src="/images/component-tree.svg" />
</div>
<p>You can see that the <code>C</code> function component was called twice, each time for a unique child of <code>B</code>.
When React traverse the render tree, after the state update, and sees that the second <code>C</code> is gone, it
will unmount it, which means React no longer listens for updates to that component's props or state.
Now let's create the same thing using hooks for state.</p>
<pre><code class="language-jsx">import React from "react";
import ReactDOM from "react-dom";

const C = () => &#x3C;>"hello"&#x3C;/>;

const B = props => &#x3C;div> &#x3C;C/> {props.b &#x26;&#x26; &#x3C;C/> &#x3C;/div>;

const A = () => {
  const [a, setA] = React.useState(true);
  useEffect(() => {
    setTimeout(() => setA(false), 5000);
  }, []);
  return &#x3C;B b={a} />;
};

ReactDOM.render(&#x3C;A/>, root);
</code></pre>
<p>In this iteration I opted to switch to using arrow functions which are often much nicer (once
you're used to them), and have other benefits compared to old-school function literals. Regardless,
you can see a lot of new stuff going on already to do the same thing. Since function components
are always the render function, there is no "constructor" or other life cycle method which we
can use to set our timeout in. Instead, we have to learn about the concept of <em>effects</em>.</p>
<p>An effect, is a function that React will run after each render, possibly with a list of
<em>dependencies</em>, states that if changed trigger the effect. Probably my favorite thing about
hooks, is how they can truly turn components into finite state machines with effects.
You have multiple state properties, and multiple effects that run at each state change, and can
listen to only when a particular state changes.</p>
<p>In <code>A</code> above, our effect says "after each render, if any of the states in this list, <code>[]</code>, changed,
set a timeout that sets the state <code>a</code> to <code>false</code> in 5000 milliseconds". When you consider that
<code>[]</code> has no states in it and realize it will never change and therefore only happens after the first
render, you have one of the first React hooks idioms, which I'll call <code>useDoAfterMount</code>. Together, it's,
"after mount, set a timeout to change the state of <code>a</code> to <code>false</code> in 5000 milliseconds".</p>
<p>As for the <code>useState</code> hook, it allows you to allocate one cell of state for the currently rendering
component in the component tree, with an initial value. This initial value is ignored in future renders.
We will return to that, but for now, suppose we added some hook state to our <code>C</code> components:</p>
<pre><code class="language-jsx">import {useState} from "react";

const C = () => {
  const [count, setCount] = useState(5);
  useEffect(() => { setInterval(() => setCount(prev=>prev+1), 1000); }, []);
  return &#x3C;>{count}&#x3C;/>;
};
</code></pre>
<p>This is a more advanced usage of a react state dispatcher (the <code>setCount</code> function returned by
<code>useState</code>). Instead of a new value, you can pass a function that gets the current value and
creates a new one from it, like how above we increment from the current value which I nickname
prev (since it's about to become the previous value). Because <code>setInterval</code> runs the function
every second, it will keep going up. If we didn't use a function for the dispatcher call, we
would do the following, which has a bug:</p>
<pre><code class="language-jsx">const C = () => {
  const [count, setCount] = useState(5);
  useEffect(() => { setInterval(() => setCount(count+1), 1000); }, []);
  return &#x3C;>{count}&#x3C;/>;
};
</code></pre>
<p>This is probably one of the hardest challenges of starting hooks. What's wrong with this code?
The issue is, when the first render is ran, and the useEffect's function is parsed, the value of
count is <code>5</code>. Since the dependencies never change (the dependency list is empty still), the hook
isn't re ran. That same function of <code>setCount(5+1)</code> is ran every second, effectively not changing
anything. Alright then, how about then we use that fancy dependency list then?</p>
<pre><code class="language-jsx">const C = () => {
  const [count, setCount] = useState(5);
  useEffect(() => { setInterval(() => setCount(count+1), 1000); }, [count]);
  return &#x3C;>{count}&#x3C;/>;
};
</code></pre>
<p>Alright, so now this... probably won't work. Think about it. On the first render, the function is called,
and the effect is ran, adding code of <code>setCount(5+1)</code> to be called every second. One second passed, the
state changes (<code>count</code> is now 6), and react rerenders, rerunning the function but this time useState
returns 6 instead of the initial state which it ignores, 5. <code>count</code> has now changed, so the effect runs
again, adding <em>another</em> code body to set state this time to <code>setCount(6+1)</code> every second. One more
second passes, and now <em>both</em> functions execute in an unpredictable order. Which will occur first and
which last? Will your the state of <code>count</code> be <code>7</code> or <code>6</code>? It gets worse, because this balloons up and
a minute later you now have 60 functions running per second, all setting the state to different things.
Avoiding dependencies on state when you can just transform the current state in the dispatcher's
argument is key to avoiding asynchronous programming headaches, so use it whenever possible.</p>
<p>With that out of the way, we can take the brief descriptions and formalize what the <code>useState</code> hook
does, and why React actually has something called the <a href="https://reactjs.org/docs/hooks-rules.html">rules of hooks</a>.
<code>useState</code> allocates a singular state reference for the currently rendering component when the
component is first rendered. On all renders, it then returns the current state. Notice, that the
<code>useState</code> parameters don't include any identifier for identifying which state you want, you don't
ask for <code>useState('count', 5)</code>. This is because React uses the ordered nature of javascript to
figure out which state you're asking for. Because of using this order, you <em>cannot use hooks in
conditional code</em>. You have to extract it from the conditional code, or strange thing could happen.</p>
<pre><code class="language-jsx">const C = props => {
  const [a, setA] = useState(true);
  let b, setB, c, setC;
  if (props.blah) {
    [b, setB] = useState([]);
  } else if {
    [c, setC] = useState({});
  }
  return null; // same as empty jsx
};

const B = props => {
  return &#x3C;> &#x3C;C/> &#x3C;C/> &#x3C;>
};
</code></pre>
<p>When <code>C</code> renders, React allocates two state cells, but if <code>props.blah</code> flips its truth value,
then <code>b</code> and <code>c</code> will flip which state they get from React. For these reasons, people usually use
linters to detect and warn them about using hooks in ways that can cause this strange behavior.
For the same reasons, you cannot run hooks in loops or other dynamic ways, they need to be run
at function scope.</p>
<!-- transition? -->
<p>Now, let's have a final note on the alternative to class instances, and then we can really get to work.
When <code>B</code> renders, how does React know which <code>a</code>, <code>b</code>, and <code>c</code> state references to give to it?
Unlike the class components where React keeps and maintains an instance, React needs to think a bit
harder. React remembers the <em>path</em> it took to render this component. If we were to run
<code>ReactDOM.render(&#x3C;B/>, root)</code>, React sees three component instances. It sees something like:</p>
<pre><code>1: 
  path: /B
  renderer: B
2: 
  path: /B/C:1
  renderer: C

3: 
  path: /B/C:2
  renderer: C
</code></pre>
<p>But if you look at our first example of JSX, how can it tell where components are in the render
function if they are generated dynamically like so?</p>
<pre><code class="language-jsx">var people = [{name: 'John', age: 25}, {name: 'Mike', age: 22}];
ReactDOM.render(
  &#x3C;ul>
    {people.map(person => &#x3C;li> {person.name} is {person.age} years old &#x3C;/li>)}
  &#x3C;/ul>,
  root
);
</code></pre>
<p>You could associate state by the order they come in, but react does one better and requires you to
pass a special key prop in all list-generated children to tell react which is which, allowing
your list to be in any order and change in any way. If a component shows up with a different key,
it will be newly mounted with fresh state, if a component's props change but it has the same key,
it is identified as the owner of that state and rerenders. It is important that your keys are
unique, or React will only render one of them.</p>
<pre><code class="language-jsx">ReactDOM.render(
  &#x3C;ul>
    {people.map(p => &#x3C;li key={p.name}> {p.name} is {p.age} years old &#x3C;/li>)}
  &#x3C;/ul>,
  root
);
</code></pre>
<p>And with that in-depth explanation of most of reacts internals, we should be set to build our
RPG point buy system for real, let's return to our original concept with some tweaks:</p>
<pre><code class="language-tsx">declare var React: any;
declare var ReactDOM: any;

class AttributeCounter extends React.Component {
  constructor() {
    this.state = { value: 10 };
  }
  render() {
    return (
      &#x3C;span>
        {this.props.name}: {this.state.value}
        &#x3C;button>+&#x3C;/button>
        &#x3C;button>-&#x3C;/button> 
      &#x3C;/span>
    );
  }
}

function PointBuy(props) {
  return (
    &#x3C;AttributeCounter name={"Strength"} />
    &#x3C;AttributeCounter name={"Charisma"} />
    &#x3C;AttributeCounter name={"Wisdom"} />
  );
}

ReactDOM.render(
  &#x3C;PointBuy/>,
  document.getElementById('root')
);
</code></pre>
<p>Let's start by <em>lifting</em> the state out of the children into the parent, so that the parent
can impose concurrent constraints.</p>
<pre><code class="language-tsx">declare var React: any;
declare var ReactDOM: any;
// extrace useState function from react
const { useState } = React;

class AttributeCounter extends React.Component {
  render() {
    return (
      &#x3C;span>
        {this.props.name}: {this.props.value}
        &#x3C;button onClick={this.props.onInc>+&#x3C;/button>
        &#x3C;button onClick={this.props.onDec>-&#x3C;/button>
        &#x3C;button>-&#x3C;/button> 
      &#x3C;/span>
    );
  }
}

function PointBuy(props) {
  const [str, setStr] = useState(10);
  const [cha, setCha] = useState(10);
  const [wis, setWis] = useState(10);
  return (
    &#x3C;AttributeCounter name={"Strength"} value={str}
      onInc={()=>setStr(p=>p+1)} onDec={()=>setStr(p=>p-1)}
    />
    &#x3C;AttributeCounter name={"Charisma"} value={cha}
      onInc={()=>setCha(p=>p+1)} onDec={()=>setCha(p=>p-1)}
    />
    &#x3C;AttributeCounter name={"Wisdom"} value={wis}
      onInc={()=>setWis(p=>p+1)} onDec={()=>setWis(p=>p-1)}
    />
  );
}

ReactDOM.render(
  &#x3C;PointBuy/>,
  document.getElementById('root')
);
</code></pre>
<p>And if you get this far... well you're going to have to do the rest now!</p></div><hr/></div><div class="blog-module--post--1jMia"><h1>Always use a Monorepo</h1><h3>February 15, 2020</h3><div><p>Always use a monorepo. Because otherwise the temptation to jam more stuff into one package is too strong.
Context switches are annoying, and that may prevent you from correctly crossing package lines when thinking
where to put your code. In my terrible opinion you can always extract the history out to
a separate repo later with <a href="https://github.com/newren/git-filter-repo">git filter-repo</a>.</p>
<p>Anyway, the <em>real</em> reason to use a monorepo is because in tooling environments like HTML5
JavaScript stacks (e.g. create-react-app),
(where monorepo jargon is especially popular) you can expose custom linter rule packages that
bend everyone to your all-knowing will!!!!!! In a work project recently, we had some Sass theming logic
that I deprecated in favor of a more direct, less complicated method for achieving the same thing.
We all wanted a better method and had been looking for a while.
Deprecating it was a great step, but in a large product code base, there's little value and
possible danger in taking a long time to rewrite all of the deprecated references.
The ideal approach is "progressive migration"â€”not wasting time converting everything
that works fine as is, but slowly converting anything that needs maintenance, implying a
sort of LRU chipping away at usage of the deprecated styling technique. Since we were already using
lint-staged+husky to force linting of vcs-staged files precommit, I just added the new
deprecation rule and set it to error, so
other developers could not change style files without first migrating the deprecated references.
It's a tad intense since it still
demands that you migrate any file you may make small changes to, but it ensures active files receive
the love of an easier theming logic so future maintenance is easier.</p>
<p>Without a very proper naming scheme, or private package registry like we have, project-scope
packages are a bit difficult to justify. But, if you're careful, there's a lot of value and change
you can bring about by reading your linters' APIs.</p>
<p>Without a monorepo setup, I'd have had to setup a separate repository and publishing pipeline. Not
a ton of work, but for a utility of exactly project-scope it belongs in your project's source
(vcs) context. I especially opted for this since stylelint only seems to support package-level
custom rules (afaik). I'm sure a module-level custom rule would have been nicer for something
project-only.</p>
<p>JS Monorepos can come with their own headaches, but the scalable reusability is essential.</p></div><hr/></div><div class="blog-module--post--1jMia"><h1>Eye Progress</h1><h3>December 19, 2019</h3><div><p>I've been working on a human eye recently. It's not done, but I think I'll put up a description (or even a youtube tutorial?)
on how to make a fully procedural eye once I'm done. Or at least a vanity post of how many nodes I used.
It contains <em>no</em> images/textures. Everything is generated using math and noise
functions, in particular Blender's standard Cycle's Perlin noise implementation, Musgrave, and Voronoi.</p>
<div style="text-align:center">
  <img style="width:50%" alt="you seem to not be able to see the image" src="/images/the_eye.png" />
</div>
<p>You can tell it's not done based on the iris color, and the fact that I haven't rendered it with the clear gel layer that the
eye typically has around it, which would cause some much needed refraction. Also this version doesn't tone down the veins as
much as needed.  Still, I'm pretty happy with some of the results so far so I figured I'd put it out here.</p></div><hr/></div><div class="blog-module--post--1jMia"><h1>Blender 2.8 Grease Pencil Is Awesome</h1><h3>July 13, 2019</h3><div><p>I needed to do a top-down draft, a design of something I would be 3D-modeling later, and so I opened up
my 2D drawing toolkit, Krita. I bumped the resolution to
5000x5000 pixels, and had to think deeply about it.</p>
<p>The lack of dynamic resolution in such raster based D image manipulation programs is saddening. Especially
in my drafting process. It's inconvenient to have to worry about blurry details when zooming in too far, or slow stroke
rendering/committing when zooming out too much. So, since I already use Blender for practically everything else and
was enjoying the quality of life improvements in Blender 2.8 recently, I decided to check out its new 2D (Grease Pencil) tools for kicks.
Lo and behold, the lagless, vector-based, infinite resolution, hassle-free zoom, layered, materialed, simple, beautiful 2D workspace of my
dreams was before me. Gone are the drafting days of drawing arrows to various scene elements to elaborate on them.
Just zoom into them! You can just zoom infinitely and write inside them. The brushes are clean, and
customizable. Erasing is instant (use point-erase), and rendering is lagless. And since you're not
dealing with raster, there are <em>no</em> complex selections to perform. You can select strokes independently,
select their points, move things, scale things, and it takes no time at all. You can <em>sculpt</em> your points,
adding or reducing thickness of lines, moving them, adding some fuzziness, simplifying them, and more. It's not
just good for drafting, but all drawing comes naturally to it. And you can even extend it to 3D! Draw in 3D,
start modeling in 3D. Draw on your 3D models to concept some greebling if your artstyle demands it!
It has never felt so easy to me. Blender has always been good at what it does,
but it has never felt so exceptionally designed until now. Whether you're designing interfaces or levels, doing
3D graphics work, doing 2D work, or any animation, definitely get into Blender 2.8 and start a new 2D drawing
project. It just works!</p></div><hr/></div><div class="blog-module--post--1jMia"><h1>Melkman Algorithm Visualization</h1><h3>May 04, 2019</h3><div><p>For my computational geometry course, I and a small team of my peers wrote a
visualization comparing the naive and the Melkman convex hull
finding algorithms, with some pedagogical narration. It
was a fun opportunity to really learn Elm for HTML5 content authoring, and SVG rendering.
<a href="https://mikemikeb.com/convex-hull-visualization/">See it here</a>.</p>
<p>The narration needs better interactivity, the style is pretty poor and there's no mobile support,
so I need to come back and polish it some night. It was made in <a href="https://elm-lang.org/">elm</a>.</p></div><hr/></div><div class="blog-module--post--1jMia"><h1>Empowering LaTeX (PyLaTeXc)</h1><h3>May 04, 2019</h3><div><p>The one nagging gap in my homework development stack early on
was an itch for
programmability, that trait which Excel is alleged to have.
But I have a gripe with Excel. It's like Scratch for adults,
A psuedoscripting language for the uninitiated and unlearned.
Personally, I've always kicked up a Python interpreter any
time I needed a calculation, and I quickly began depending on
Python+scipy for more intense derivations and data routines. I scratched
up a utility module for producing LaT<sub>E</sub>X tables and pgfplots graphics
from various data formats, and used it frequently with minimal
copy and paste glue (thank you Cygwin's
<code>/dev/clipboard</code>).</p>
<p>But larger projects begged for more complete tools; like that assignment
involving the visualization
of 26 different samples from a dataset, as well as calculating some
statistical metrics about each sample.
A sane person would have used the charting features
in the Excel spreadsheet it was provided in, but that's outside the scope
of this post.
I exported to csv immediately and made an incredibly primitive
toolkit for embedding Python logic in LaT<sub>E</sub>X. Revisiting it a
couple of months later, I refined my toolkit massively and today I
would consider the design complete, but alternative implementation
approaches merit some exploration.</p>
<p>The first time I attemped glueing my Pythonisms into LaT<sub>E</sub>X,
my design was a tiny mapping from a LaT<sub>E</sub>X grammar extension
to Python formatting key syntax.
If I were to write my LaT<sub>E</sub>X code directly in a Python string,
and attempt to use formatting keys,
I would probably spontaneously combust. It looks like this:</p>
<pre><code class="language-python">r"""\begin{{document}}
\frac{{ {kill} }}{{ {me} }}
\end{{document}}""".format(kill=5, me=10)
</code></pre>
<p>That's almost as crufty as chained ternary expressions in JSX.
Backslash doubling I can avoid by making it a raw string, but that
isn't an option in all use cases.
Regardless, I hid this formatting ugliness behind a script, which
escaped braces for me, and interpretted the characters '&#x3C;&#x3C;' as '{', and
'>>' as '}'. So now I didn't have to brace every 5 characters, and the
keys looked distinct from the LaT<sub>E</sub>X syntax.
My dumb and ugly LaT<sub>E</sub>X superset templater took about 5 lines of
Python code to process, and the source looked like:</p>
<pre><code class="language-python">\begin{document}
\frac{&#x3C;&#x3C;numerator>>}{&#x3C;&#x3C;denominator>>}
\end{document}
</code></pre>
<p>Quite literally, all my template processor had to do was replace all braces with
escaped double braces, and then replace all
double angle brackets with a single formatting brace, thus yielding
the valid Python formatting keys, while allowing raw LaT<sub>E</sub>X to look
at least familiar.
Then you just produce your values and/or data in your Python script,
read this template from some file,
and submit it to Python's formatting functinos with the expected keyword
arguments that you used in the document source
(e.g. &#x3C;<numerator>>).
Here's the naive templating implementation:</p>
<pre><code class="language-python">def load_pytex(path, **kwargs):
  txt = open(path).read()
  txt = txt.replace('{','{{').replace('}','}}')    
  txt = txt.replace('&#x3C;&#x3C;', '{').replace('>>', '}')
  txt.format(**kwargs)
  return txt  # or subproc.check_output(['pdflatex' ...])
</code></pre>
<p>So this works, but it would be quite annoying to have a Python
context so decoupled from the usage context. Calculating things
without regard to the location in the document, and being
unable to change the logic while editing the document without
switching files.
Certainly I could do better? So I did something sinful.</p>
<p>Fake macros in LaT<sub>E</sub>X will make this all look way more T<sub>E</sub>X-savvy.
Let's add a <code>\pyeval</code> pseudo-command, and a
<code>pyexec</code> pseudo-environment so that we can get something
like so:</p>
<pre><code class="language-python">\begin{pyexec}
name = 'John'
\end{pyexec}

Hello I am \pyeval{' '.join([name,'Smith'])}
</code></pre>
<p>Originally I implemented (knowing my transgressions) a naive
regular expression based implementation, but this has many problems</p>
<ul>
<li>I want to ignore false ends in quotes and comments</li>
<li>I want to allow counting of nested braces in pyeval</li>
</ul>
<p>expressions so that you don't need to escape all right
braces. (Regular expressions can't find the valid ending
brace of a nested expression)
Checkout the following counter_examples:</p>
<pre><code class="language-python">\begin{pyexec}
hate_you = r'\end{pyexec}'  # we need to avoid ending if its in a literal
\end{pyexec}

\pyeval{h = {'hello': 'world', 'x': {}}}  # which brace do we end on?
</code></pre>
<p>So I couldn't use regular expressions for this, but I still wanted it.
Because my LaT<sub>E</sub>X document source would look like this:</p>
<pre><code class="language-python">\begin{pyexec}
from scipy.optimize import curve_fit
from random import random as rand
from itertools import count, product as crossproduct
bin = crossproduct((0,1),repeat=5)
data = list(zip(count(), bin))
# add a count of set bits as a column
for row in data:
d, b = row
row.append(b.count(1))
randpts = [[rand(),rand()] for _ in range(100)]
\end{pyexec}

\section*{Data Stuff}

\begin{tabular}{|c|c|}
\hline
Decimal &#x26; Binary &#x26; 1-Bits \\
\hline
\pyeval{'\n'.join(('&#x26;'.join(map(str,d)) for d in data))}
% we can extract the above one-liner for reuse in tabular 
% construction and any horizontally partitioned context
\hline
\end{tabular}

% use unpack+zip hack to get separate lists of x then y coords
Best Fit: \pyeval{curve_fit(lambda x,m,b: m*x+b, zip(*randpts))} 
</code></pre>
<p>Mmmmm... delicious. It looks so much like Python yet so much like LaT<sub>E</sub>X.
It's both at once, without crippling either one! It's logic embedded in the document
markup cleanly. So I did go and implement it. Originally I tried using a more
complicated parsing approach, PyParsing, but it turned out to be far too complicated
for what was essentially templating. I ended up settling on parsing by character, due
to the simplicity of the extension. There are a few performance enhancements I could
make but I'm not in the need of them right now, and I've noted them for posterity in
my README. This is PyLaT<sub>E</sub>X, and I put it on my
<a href="https://github.com/MichaelBelousov/pylatexc">GitHub</a></p>
<p>At last, I would argue, that we have a tool more extensible than Excel,
it's got all of PyPI behind it, with numpy, scipy, and all the packages
you could want&#x26;emdash; embedded in your document.
If you like this approach, maybe you can be just as sinful and throw it into
Markdown, or change up the scripting language to your preference. So long as you
don't use php. Even if it's already a templating language.</p>
<pre><code class="language-markdown">My Document
===========

```pyexec
import csv
data = list(csv.reader('mycsv.csv'))
```
`>>> '\n'.join(data)`
</code></pre>
<p>And as a final note, check out <a href="https://typora.io/">Typora</a>
other cool ways to not use Office products. I don't actually use it, but the LaT<sub>E</sub>X
in Markdown makes me want to. Even if I'm not in school any more.</p>
<style>
span.vim {
    font-size: 3pt;
}
</style></div><hr/></div><div class="blog-module--post--1jMia"><h1>Bill Wurtz</h1><h3>August 28, 2018</h3><div><p>Shout-out to Bill Wurtz.</p>
<p>His website is a real treat, it harkens back to the early web styles (or lack thereof). It reminds me of a simpler time when websites were awesome.</p>
<p>Check it out: <a href="https://billwurtz.com">billwurtz.com</a></p></div><hr/></div><div class="blog-module--post--1jMia"><h1>Super Thin RAII Wrappers for C Types</h1><h3>June 17, 2018</h3><div><p>Let's partake in some template indulgence. Suppose we have some C files
that we're linking to our amazing C++ project, but it leaves us with
a few sad C "constructors" and "destructors" surrounding a struct, as a
language without implicit object constructionr. Suppose we have a struct: <code>struct MyCType</code>,<br>
a "constructor" for it: <code>MyCtype* Create_MyCType()</code> and a "destructor"
for it too: <code>Free_MyCType(MyCType*)</code>.</p>
<p>If you don't know what
<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">Resource Acquisition is Initialization</a>
is, you should check it out, it's a useful programming idiom, often associated with C++ (and Rust),
that you probably already use somewhere.
So the question is, how can we get ourselves some nice RAII, scope-based destruction
for this type with minimal boiler plate? </p>
<p>Our goal is that we can transform this code:</p>
<pre><code class="language-cpp">void myFunc()
{
  CType* ctype = initialize_CType();
  //do something with c type
  destroy_CType(ctype);
}
</code></pre>
<p>Into this code:</p>
<pre><code class="language-cpp">void myFunc()
{
    WrappedCType type;
    //do something with it
}
</code></pre>
<p>Isn't that much cleaner?
I'll look into using the STL for a great, simple solution, and then a custom
wrapper emphasizing performance.</p>
<p>Indeed, it turns out we can actually do what we want there
<em>very</em> easily, having decent knowledge of the STL, the natural solution to the
problems that most over-zealous c++ programmers have.
Let's give this an STL solution before we look into a custom one and later we'll
see what kind of performance gains we can find and if it's worth it.
But first, let's define some contrived "C code", structs and functions that we
will attempt to wrap. We'll assume it's partitioned into headers and implementation
source as the files in our working directory of "ctype.h" and "ctype.c".</p>
<pre><code class="language-cpp">// === ctype.h =============

typedef struct {
  int s;
  unsigned long long t;
} ExampleSubType;

typedef struct {
  int a;
  float b;
  ExampleSubType* sub;
} ExampleCType;

// === ctype.c ============

ExampleCType* Create_ExampleCType(int i, float f)
{
  //pardon any mistakes, in my tests I used C++ allocation
  //i.e. new ExampleCType{i,f, new ExampleSubType{5, ...}};
  ExampleCType* result = malloc(sizeof(ExampleCType));
  result->a = i;
  result->b = f;
  result->sub = malloc(sizeof(ExampleSubType));
  result->sub->s = 5;
  result->sub->t = 334323464592ULL;
  return result;
}

void Free_ExampleCType(ExampleCType* in)
{
  free(in->sub);
  free(in);
}
</code></pre>
<p>So, how can we elegantly use the STL To initialize with our Create function,
and destroy with our Delete function? The real hint should be our intended scope
based destruction. We can provide a smart pointer with a custom deleter, which
happens to match our intended signature. If it didn't, we could still probably use
a fitting lambda expression to map it to the required deleter signature. Let's do it
as follows:</p>
<pre><code class="language-cpp">#include &#x3C;ctype.h>
#include &#x3C;type_traits>
#include &#x3C;memory>
#include &#x3C;iostream>
using namespace std;  //for brevity and tersity

template&#x3C;auto Create, auto Delete, typename... CreateArgTypes>
shared_ptr&#x3C;
typename remove_pointer&#x3C;
decltype(Create(declval&#x3C;CreateArgTypes>()...))>::type>
makeCTypeWrapper(CreateArgTypes&#x26;&#x26;... args)
{
  using CTypePtr = decltype(Create(declval&#x3C;CreateArgTypes>()...));
  using CType = typename remove_pointer&#x3C;CTypePtr>::type;
  return shared_ptr&#x3C;CType>(Create(args...), Delete);
}

int main()
{
  //Example example_inst{1, 0.5f};
  auto example_inst = makeCTypeWrapper&#x3C;
  Create_ExampleCType,
    Free_ExampleCType>
  (-5, 0.5f);
  cout &#x3C;&#x3C; "peek at the instance's 'a' member" &#x3C;&#x3C; endl;
  cout &#x3C;&#x3C; example_inst->a &#x3C;&#x3C; endl;
  cout &#x3C;&#x3C; "peek at the instance's 'sub' member's 't' member" &#x3C;&#x3C; endl;
  cout &#x3C;&#x3C; example_inst->sub->t &#x3C;&#x3C; endl;
}
</code></pre>
<p>This has some awesome advantages. Copy prevention (if you use unique<em>ptr),
reference counting, all the things that come with smart pointers. The one
issue is, what if the library you're using already does reference counting?
What if this is just too much overhead for what you're doing? Exploring a
more raw wrapper is the next step, but before that, I'll first show what would
make a lovely addition to the above code... if C++ allowed deduced arguments for
templated aliases. Using a function pointer variable type alias, we can craft
a single, make</em>Example() function with no template parameters. Unfortunately, without
deduction, you would have to explicitly list the argument types which is ugly
and worst of all redundant. Either way, it might look something like this:</p>
<pre><code class="language-cpp">template&#x3C;typename... ArgTypes>
shared_ptr&#x3C;ExampleCType>(*make_Example(ArgTypes...) = 
    &#x26;makeCTypeWrapper&#x3C;Create_ExampleCtype, Free_ExmapleCType, ArgTypes...>;
</code></pre>
<p>So then, we're on to a raw wrapper. How thin can we make it?
Can we make the wrapping inlined by the compiler entirely? I will explore the latter
question and discuss it in another article. For now we'll just bring the wrapper into
existence. That question is what I'd like to use to determine if the
smart_pointer solution is worth it in performance-critical contexts.</p>
<p>We'll start with the idea for our template that hopefully will inevitably do everything
we want.</p>
<pre><code class="language-cpp">template&#x3C;typename CType, CType*(Create*)(), void(Free*)(CType*)>
struct CTypeWrapper;
</code></pre>
<p>We've got function pointer type value arguments to our template already, and later
we'll add variadic arguments to match any signature for the Create function. This
could be used to match different overloads but unfortunately it seems difficult to
infer the overload so we can't do much without boilerplate as far as my
intelligence falls.
We can at least infer the wrapped type itself from the function pointer arguments.
For now let's put in a simple implementation and see how it compiles.</p>
<p>I ended up adding some additional templated aliases for the function pointer
types, which makes it much more comprehensible, but these will disappear in the
C++17 version.</p>
<pre><code class="language-cpp">template&#x3C;T>
using CreateFunc = T*(*)();

template&#x3C;T>
using FreeFunc = void(*)(T*);

template&#x3C;typename CType, 
  CreateFunc&#x3C;CType&#x3C; Create, 
  FreeFunc&#x3C;CType&#x3C; Free&#x3C;
struct CTypeWrapper
{
  CType* wrapped;
  CTypeWrapper()
    : wrapped(Create())
  {}
  ~CTypeWrapper()
  {
    Free(wrapped);
  }
  //implicit conversion to wrapped type
  operator CType* ()
  {
    return wrapped;
  }
  CType* operator->()
  {
    return wrapped;
  }
};
</code></pre>
<!--

I should probably say by now that there will be some elements of danger
to stuff I am discussing, but one of the cool things (I think) you can do
with this type is safely cast a reference of it to the underlying pointer.

-->
<p>Now let's use our contrived C example and see what happens</p>
<pre><code class="language-cpp">#include"ctype.h"
#include"CTypeWrapper.h"
#include &#x3C;iostream>

using namespace std;  //for brevity and tersity
//our shiny type wrapper
using Example = CTypeWrapper&#x3C;ExampleCType, 
      Create_ExampleCType, 
      Free_ExampleCType>;

int main()
{
  Example example_inst;
  cout &#x3C;&#x3C; "peek at the instance's 'a' member" &#x3C;&#x3C; endl;
  cout &#x3C;&#x3C; example_inst->a &#x3C;&#x3C; endl;
  cout &#x3C;&#x3C; "peek at the instance's 'sub' member's 't' member" &#x3C;&#x3C; endl;
  cout &#x3C;&#x3C; example_inst->sub->t &#x3C;&#x3C; endl;
}
</code></pre>
<p>Assuming "CTypeWrapper.h" contains our templates we've made, we should be good
to go. Our output is:</p>
<pre><code>peek at the instance's 'a' member
100
peek at the instance's 'sub' member's 't' member
334323464592
</code></pre>
<p>So we've got implicit conversion to the underlying type, and an overrided
<code>operator-></code>to
provide access to the underlying type. This should feel a bit worrisome actually,
because our type <em>should</em> feel like a value, not a pointer, but overriding the
<code>.</code>  operator is out of the question for good reason and the
<code>-></code> syntax reminds us that our type really just contains an underlying
pointer so in my opinion it's, <em>ok</em>, not great. Definitely sinful.</p>
<p>I tried with some difficulty to find out how one can template alias the type
to provide a variadic constructor, but unfortunately I don't believe it's possible
since the first two types cannot be deduced in a class construction context
and template aliases can't either (as far as I know up to c++17). The function
deduction context appears to correctly deduce the types even with only the partial
explicit template parameters, but the class doesn't seem to be able to. I couldn't
figure out a deduction guideline for it either, but I will
look into the difference in deduction rules for classes and functions, and confirm
or fix my loss here.
This minimal and I think "acceptable" boilerplate is the
farthest I got for generic RAII wrappers of C-style types. If you're looking to C++-ify
your C-using code, try something like this, but clearly a heavy duty careful wrapper is
the real solution to any sufficient project. There are a few more hacks for quick wrapping
of C types that I explored and may revisit later, but for now I'll leave the code where
I left off, with a tidy wrapper which unfortunately has some definition boilterplate.</p>
<pre><code class="language-cpp">#include "ctype.h"
#include &#x3C;type_traits>

template&#x3C;
auto Create, 
     auto Free,
     typename... CreateArgTypes>
struct CTypeWrapper
{
  private:
    using CTypePtr = decltype(Create(std::declval&#x3C;CreateArgTypes>()...));
  public:
    CTypePtr wrapped;
    CTypeWrapper(CreateArgTypes&#x26;&#x26;... args)
      : wrapped{Create(args...)}
    {}
    ~CTypeWrapper()
    {
      Free(wrapped);
    }
    operator CTypePtr ()
    {
      return wrapped;
    }
    CTypePtr operator->()
    {
      return wrapped;
    }
};

using Example = CTypeWrapper&#x3C;
Create_ExampleCType, 
  Free_ExampleCType, 
  int, double>;

#include &#x3C;iostream>
using namespace std;  //for brevity and tersity

int main()
{
  //Example example_inst{1, 0.5f};
  Example example_inst{-5, 0.5f};
  cout &#x3C;&#x3C; "peek at the instance's 'a' member" &#x3C;&#x3C; endl;
  cout &#x3C;&#x3C; example_inst->a &#x3C;&#x3C; endl;
  cout &#x3C;&#x3C; "peek at the instance's 'sub' member's 't' member" &#x3C;&#x3C; endl;
  cout &#x3C;&#x3C; example_inst->sub->t &#x3C;&#x3C; endl;
}
</code></pre>
<p>I'll add a follow up article some day for analyzing some of the
llvm-ir assembly instructions that the clang compiler can emit to get a good idea
at the overhead the wrapper incurs and how to minimize it or potentially eradicate
it with optimization and inlining. If you find better ways, as I'm sure you will,
please send me an email.</p></div><hr/></div></main></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/blog/";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"app":["/app-c4e5362c755ea511c67f.js"],"component---src-pages-3-d-tsx":["/component---src-pages-3-d-tsx-ce657983c8681eb6b7e2.js"],"component---src-pages-404-tsx":["/component---src-pages-404-tsx-b802f626a36c01b33ab4.js"],"component---src-pages-blog-tsx":["/component---src-pages-blog-tsx-1ba1cce2f1c8683eda33.js"],"component---src-pages-index-tsx":["/component---src-pages-index-tsx-006b16db76c3f053e3af.js"],"component---src-pages-work-tsx":["/component---src-pages-work-tsx-0854640c706eb8f650d6.js"]};/*]]>*/</script><script src="/webpack-runtime-eff488184acabec803dc.js" async=""></script><script src="/app-c4e5362c755ea511c67f.js" async=""></script><script src="/framework-4f6f95a87e6130d5bbab.js" async=""></script><script src="/commons-c13a4d43faf544c814b7.js" async=""></script><script src="/component---src-pages-blog-tsx-1ba1cce2f1c8683eda33.js" async=""></script><script src="/styles-f12963b3798c232a68f6.js" async=""></script></body></html>