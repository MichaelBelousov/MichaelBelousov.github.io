<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/styles.2267388ec667be27710a.css">._3d-module--container--3u9YK{display:flex;flex-wrap:wrap}._3d-module--container--3u9YK img{max-height:200px}.work-module--container--31LKz{overflow:hidden}.work-module--pdf--8cbUT{width:100%}@media only screen and (max-width:700px){.header-module--pageWrapper--1ij_0{padding:12px}}@media only screen and (min-width:700px){.header-module--pageWrapper--1ij_0{padding:22px 1in 1in}}.header-module--separate--G80zA{display:flex;align-items:center;justify-content:space-between}.header-module--separate--G80zA .header-module--left--2-ITV{display:flex;flex-direction:row;flex-wrap:wrap;margin-left:-22px;padding:11px}.header-module--separate--G80zA .header-module--left--2-ITV .header-module--navLink--1IuEZ{margin:11px}.header-module--separate--G80zA .header-module--left--2-ITV .header-module--navLink--1IuEZ,.header-module--separate--G80zA .header-module--left--2-ITV .header-module--navLink--1IuEZ:link,.header-module--separate--G80zA .header-module--left--2-ITV .header-module--navLink--1IuEZ:visited{font-size:2rem;color:rgb(var(--body-rgb));text-decoration:initial;font-style:italic;font-weight:700;transition:font-size .1s ease;height:2.5rem;vertical-align:middle}@media only screen and (max-width:700px){.header-module--separate--G80zA .header-module--left--2-ITV .header-module--navLink--1IuEZ,.header-module--separate--G80zA .header-module--left--2-ITV .header-module--navLink--1IuEZ:link,.header-module--separate--G80zA .header-module--left--2-ITV .header-module--navLink--1IuEZ:visited{font-size:1.5rem}}.header-module--separate--G80zA .header-module--left--2-ITV .header-module--navLink--1IuEZ:hover{color:orange;font-size:2.5em}@media only screen and (max-width:700px){.layout-module--pageWrapper--22gEu{padding:12px}}@media only screen and (min-width:700px){.layout-module--pageWrapper--22gEu{padding:22px 1in 1in}}body{margin:0;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;background-color:rgb(var(--background-rgb));color:rgb(var(--body-rgb))}code{font-family:source-code-pro,Menlo,Monaco,Consolas,Courier New,monospace}a{color:#49a9f9}a:visited{color:#69a9f9}a:active{color:#b9b999}h1{font-size:1.4em;font-weight:700}h1,h3{font-style:italic}h3{font-size:1em;font-weight:400}h1+h3{margin-top:-8px}hr{color:rgba(var(--body-rgb),.3)}.blog-module--container--1pCGB{display:flex;flex-direction:column}@keyframes blog-module--spin--1ZuQ_{0%{transform:scaleX(0)}50%{transform:scaleX(1)}to{transform:scaleX(0)}}.blog-module--loader--27Uha{display:flex;align-items:center;justify-content:center}.blog-module--loader--27Uha .blog-module--inner--3N3oy{border:4px solid rgb(var(--body-rgb));height:26px;width:26px;border-radius:50%;animation-name:blog-module--spin--1ZuQ_;animation-duration:1s;animation-iteration-count:infinite;animation-timing-function:ease-out}.blog-module--post--oYMJm{width:100%}:root{--background-rgb:18,18,24;--body-rgb:239,239,239}.blog-module--blogLink--1dLLs{margin:11px}.blog-module--blogLink--1dLLs,.blog-module--blogLink--1dLLs:link,.blog-module--blogLink--1dLLs:visited{color:rgb(var(--body-rgb));text-decoration:initial;font-weight:700;vertical-align:middle}.blog-module--blogLink--1dLLs:hover{color:orange}</style><meta name="generator" content="Gatsby 2.21.13"/><title data-react-helmet="true">Super Thin RAII Wrappers for C Types | Mike Belousov&#x27;s Website</title><link data-react-helmet="true" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/a11y-dark.min.css" integrity="sha256-7L/IK7qUTcgTXtfLAxip5Eo+hnp+pSe5htBCh5pYg6o=" crossorigin="anonymous"/><meta data-react-helmet="true" name="description" content="See title"/><meta data-react-helmet="true" property="og:title" content="Super Thin RAII Wrappers for C Types"/><meta data-react-helmet="true" property="og:description" content="See title"/><meta data-react-helmet="true" property="og:type" content="website"/><meta data-react-helmet="true" name="twitter:card" content="summary"/><meta data-react-helmet="true" name="twitter:creator" content="Mike Belousov"/><meta data-react-helmet="true" name="twitter:title" content="Super Thin RAII Wrappers for C Types"/><meta data-react-helmet="true" name="twitter:description" content="See title"/><link rel="icon" href="/favicon-32x32.png?v=bdc2871edacbda8dd5a11f8bfaedcd63"/><link rel="manifest" href="/manifest.webmanifest"/><meta name="theme-color" content="#663399"/><link rel="apple-touch-icon" sizes="48x48" href="/icons/icon-48x48.png?v=bdc2871edacbda8dd5a11f8bfaedcd63"/><link rel="apple-touch-icon" sizes="72x72" href="/icons/icon-72x72.png?v=bdc2871edacbda8dd5a11f8bfaedcd63"/><link rel="apple-touch-icon" sizes="96x96" href="/icons/icon-96x96.png?v=bdc2871edacbda8dd5a11f8bfaedcd63"/><link rel="apple-touch-icon" sizes="144x144" href="/icons/icon-144x144.png?v=bdc2871edacbda8dd5a11f8bfaedcd63"/><link rel="apple-touch-icon" sizes="192x192" href="/icons/icon-192x192.png?v=bdc2871edacbda8dd5a11f8bfaedcd63"/><link rel="apple-touch-icon" sizes="256x256" href="/icons/icon-256x256.png?v=bdc2871edacbda8dd5a11f8bfaedcd63"/><link rel="apple-touch-icon" sizes="384x384" href="/icons/icon-384x384.png?v=bdc2871edacbda8dd5a11f8bfaedcd63"/><link rel="apple-touch-icon" sizes="512x512" href="/icons/icon-512x512.png?v=bdc2871edacbda8dd5a11f8bfaedcd63"/><link as="script" rel="preload" href="/styles-f12963b3798c232a68f6.js"/><link as="script" rel="preload" href="/component---src-components-blog-page-tsx-6d04ce94b616cd2c5bd3.js"/><link as="script" rel="preload" href="/commons-e794e0a14ff585b098df.js"/><link as="script" rel="preload" href="/framework-da8c6e3ed6a1d0c32925.js"/><link as="script" rel="preload" href="/app-c3527675040adf5ea2fd.js"/><link as="script" rel="preload" href="/webpack-runtime-16a2198acefe0c70b60a.js"/><link as="fetch" rel="preload" href="/page-data/blog/Super_Thin_RAII_Wrappers_for_C_Types/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="layout-module--pageWrapper--22gEu"><header><div class="header-module--separate--G80zA"><div class="header-module--left--2-ITV"><a class="header-module--navLink--1IuEZ" href="/">Home</a><a class="header-module--navLink--1IuEZ" href="/work">Work</a><a class="header-module--navLink--1IuEZ" href="/3d">3D</a><a class="header-module--navLink--1IuEZ" href="/blog">Blog</a></div><div><h1>Mike Belousov</h1></div></div><hr/></header><main><div class="blog-module--post--oYMJm"><h1>Super Thin RAII Wrappers for C Types</h1><h3>June 17, 2018</h3><div><h4><em>Editor's Note:</em></h4>
<p>This article abuses some C++/C interop concepts.
In reality, you should use the original C API in any C++ project
using a C dependency without official, well-supported, sane, C++ bindings,
since that will prevent cluttering the conceptual context of the API.
Regardless, we can still learn a lot for our own C++ and occasionally
C by looking at this relationship. I definitely went crazy here, but
it's all in good fun.</p>
<hr>
<p>Let's partake in some template indulgence
. Suppose we have some C files
that we're linking to our amazing C++ project, but it leaves us with
a few sad C "constructors" and "destructors" surrounding a struct, as a
language without implicit object construction. Suppose we have a struct: <code>struct MyCType</code>,<br>
a "constructor" for it: <code>MyCtype* Create_MyCType()</code> and a "destructor"
for it too: <code>Free_MyCType(MyCType*)</code>.</p>
<p>If you don't know what
<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">Resource Acquisition is Initialization</a>
is, you should check it out, it's a useful programming idiom, often associated with C++ (and Rust),
that you probably already use somewhere.
So the question is, how can we get ourselves some nice RAII, scope-based destruction
for this type with minimal boiler plate? </p>
<p>Our goal is that we can transform this code:</p>
<pre><code class="language-cpp">void myFunc()
{
  CType* ctype = initialize_CType();
  //do something with c type
  destroy_CType(ctype);
}
</code></pre>
<p>Into this code:</p>
<pre><code class="language-cpp">void myFunc()
{
    WrappedCType type;
    //do something with it
}
</code></pre>
<p>Isn't that much cleaner?
I'll look into using the STL for a great, simple solution, and then a custom
wrapper emphasizing performance.</p>
<p>Indeed, it turns out we can actually do what we want there
<em>very</em> easily, having decent knowledge of the STL, the natural solution to the
problems that most over-zealous c++ programmers have.
Let's give this an STL solution before we look into a custom one and later we'll
see what kind of performance gains we can find and if it's worth it.
But first, let's define some contrived "C code", structs and functions that we
will attempt to wrap. We'll assume it's partitioned into headers and implementation
source as the files in our working directory of "ctype.h" and "ctype.c".</p>
<pre><code class="language-cpp">// === ctype.h =============

typedef struct {
  int s;
  unsigned long long t;
} ExampleSubType;

typedef struct {
  int a;
  float b;
  ExampleSubType* sub;
} ExampleCType;

// === ctype.c ============

ExampleCType* Create_ExampleCType(int i, float f)
{
  //pardon any mistakes, in my tests I used C++ allocation
  //i.e. new ExampleCType{i,f, new ExampleSubType{5, ...}};
  ExampleCType* result = malloc(sizeof(ExampleCType));
  result->a = i;
  result->b = f;
  result->sub = malloc(sizeof(ExampleSubType));
  result->sub->s = 5;
  result->sub->t = 334323464592ULL;
  return result;
}

void Free_ExampleCType(ExampleCType* in)
{
  free(in->sub);
  free(in);
}
</code></pre>
<p>So, how can we elegantly use the STL To initialize with our Create function,
and destroy with our Delete function? The real hint should be our intended scope
based destruction. We can provide a smart pointer with a custom deleter, which
happens to match our intended signature. If it didn't, we could still probably use
a fitting lambda expression to map it to the required deleter signature. Let's do it
as follows:</p>
<pre><code class="language-cpp">#include &#x3C;ctype.h>
#include &#x3C;type_traits>
#include &#x3C;memory>
#include &#x3C;iostream>
using namespace std;  //for brevity and tersity

template&#x3C;auto Create, auto Delete, typename... CreateArgTypes>
shared_ptr&#x3C;
typename remove_pointer&#x3C;
decltype(Create(declval&#x3C;CreateArgTypes>()...))>::type>
makeCTypeWrapper(CreateArgTypes&#x26;&#x26;... args)
{
  using CTypePtr = decltype(Create(declval&#x3C;CreateArgTypes>()...));
  using CType = typename remove_pointer&#x3C;CTypePtr>::type;
  return shared_ptr&#x3C;CType>(Create(args...), Delete);
}

int main()
{
  //Example example_inst{1, 0.5f};
  auto example_inst = makeCTypeWrapper&#x3C;
  Create_ExampleCType,
    Free_ExampleCType>
  (-5, 0.5f);
  cout &#x3C;&#x3C; "peek at the instance's 'a' member" &#x3C;&#x3C; endl;
  cout &#x3C;&#x3C; example_inst->a &#x3C;&#x3C; endl;
  cout &#x3C;&#x3C; "peek at the instance's 'sub' member's 't' member" &#x3C;&#x3C; endl;
  cout &#x3C;&#x3C; example_inst->sub->t &#x3C;&#x3C; endl;
}
</code></pre>
<p>This has some awesome advantages. Copy prevention (if you use unique<em>ptr),
reference counting, all the things that come with smart pointers. The one
issue is, what if the library you're using already does reference counting?
What if this is just too much overhead for what you're doing? Exploring a
more raw wrapper is the next step, but before that, I'll first show what would
make a lovely addition to the above code... if C++ allowed deduced arguments for
templated aliases. Using a function pointer variable type alias, we can craft
a single, make</em>Example() function with no template parameters. Unfortunately, without
deduction, you would have to explicitly list the argument types which is ugly
and worst of all redundant. Either way, it might look something like this:</p>
<pre><code class="language-cpp">template&#x3C;typename... ArgTypes>
shared_ptr&#x3C;ExampleCType>(*make_Example(ArgTypes...) = 
    &#x26;makeCTypeWrapper&#x3C;Create_ExampleCtype, Free_ExmapleCType, ArgTypes...>;
</code></pre>
<p>So then, we're on to a raw wrapper. How thin can we make it?
Can we make the wrapping inlined by the compiler entirely? I will explore the latter
question and discuss it in another article. For now we'll just bring the wrapper into
existence. That question is what I'd like to use to determine if the
smart_pointer solution is worth it in performance-critical contexts.</p>
<p>We'll start with the idea for our template that hopefully will inevitably do everything
we want.</p>
<pre><code class="language-cpp">template&#x3C;typename CType, CType*(Create*)(), void(Free*)(CType*)>
struct CTypeWrapper;
</code></pre>
<p>We've got function pointer type value arguments to our template already, and later
we'll add variadic arguments to match any signature for the Create function. This
could be used to match different overloads but unfortunately it seems difficult to
infer the overload so we can't do much without boilerplate as far as my
intelligence falls.
We can at least infer the wrapped type itself from the function pointer arguments.
For now let's put in a simple implementation and see how it compiles.</p>
<p>I ended up adding some additional templated aliases for the function pointer
types, which makes it much more comprehensible, but these will disappear in the
C++17 version.</p>
<pre><code class="language-cpp">template&#x3C;T>
using CreateFunc = T*(*)();

template&#x3C;T>
using FreeFunc = void(*)(T*);

template&#x3C;typename CType, 
  CreateFunc&#x3C;CType&#x3C; Create, 
  FreeFunc&#x3C;CType&#x3C; Free&#x3C;
struct CTypeWrapper
{
  CType* wrapped;
  CTypeWrapper()
    : wrapped(Create())
  {}
  ~CTypeWrapper()
  {
    Free(wrapped);
  }
  //implicit conversion to wrapped type
  operator CType* ()
  {
    return wrapped;
  }
  CType* operator->()
  {
    return wrapped;
  }
};
</code></pre>
<!--

I should probably say by now that there will be some elements of danger
to stuff I am discussing, but one of the cool things (I think) you can do
with this type is safely cast a reference of it to the underlying pointer.

-->
<p>Now let's use our contrived C example and see what happens</p>
<pre><code class="language-cpp">#include"ctype.h"
#include"CTypeWrapper.h"
#include &#x3C;iostream>

using namespace std;  //for brevity and tersity
//our shiny type wrapper
using Example = CTypeWrapper&#x3C;ExampleCType, 
      Create_ExampleCType, 
      Free_ExampleCType>;

int main()
{
  Example example_inst;
  cout &#x3C;&#x3C; "peek at the instance's 'a' member" &#x3C;&#x3C; endl;
  cout &#x3C;&#x3C; example_inst->a &#x3C;&#x3C; endl;
  cout &#x3C;&#x3C; "peek at the instance's 'sub' member's 't' member" &#x3C;&#x3C; endl;
  cout &#x3C;&#x3C; example_inst->sub->t &#x3C;&#x3C; endl;
}
</code></pre>
<p>Assuming "CTypeWrapper.h" contains our templates we've made, we should be good
to go. Our output is:</p>
<pre><code>peek at the instance's 'a' member
100
peek at the instance's 'sub' member's 't' member
334323464592
</code></pre>
<p>So we've got implicit conversion to the underlying type, and an overrided
<code>operator-></code>to
provide access to the underlying type. This should feel a bit worrisome actually,
because our type <em>should</em> feel like a value, not a pointer, but overriding the
<code>.</code>  operator is out of the question for good reason and the
<code>-></code> syntax reminds us that our type really just contains an underlying
pointer so in my opinion it's, <em>ok</em>, not great. Definitely sinful.</p>
<p>I tried with some difficulty to find out how one can template alias the type
to provide a variadic constructor, but unfortunately I don't believe it's possible
since the first two types cannot be deduced in a class construction context
and template aliases can't either (as far as I know up to c++17). The function
deduction context appears to correctly deduce the types even with only the partial
explicit template parameters, but the class doesn't seem to be able to. I couldn't
figure out a deduction guideline for it either, but I will
look into the difference in deduction rules for classes and functions, and confirm
or fix my loss here.
This minimal and I think "acceptable" boilerplate is the
farthest I got for generic RAII wrappers of C-style types. If you're looking to C++-ify
your C-using code, try something like this, but clearly a heavy duty careful wrapper is
the real solution to any sufficient project. There are a few more hacks for quick wrapping
of C types that I explored and may revisit later, but for now I'll leave the code where
I left off, with a tidy wrapper which unfortunately has some definition boilterplate.</p>
<pre><code class="language-cpp">#include "ctype.h"
#include &#x3C;type_traits>

template&#x3C;
auto Create, 
     auto Free,
     typename... CreateArgTypes>
struct CTypeWrapper
{
  private:
    using CTypePtr = decltype(Create(std::declval&#x3C;CreateArgTypes>()...));
  public:
    CTypePtr wrapped;
    CTypeWrapper(CreateArgTypes&#x26;&#x26;... args)
      : wrapped{Create(args...)}
    {}
    ~CTypeWrapper()
    {
      Free(wrapped);
    }
    operator CTypePtr ()
    {
      return wrapped;
    }
    CTypePtr operator->()
    {
      return wrapped;
    }
};

using Example = CTypeWrapper&#x3C;
Create_ExampleCType, 
  Free_ExampleCType, 
  int, double>;

#include &#x3C;iostream>
using namespace std;  //for brevity and tersity

int main()
{
  //Example example_inst{1, 0.5f};
  Example example_inst{-5, 0.5f};
  cout &#x3C;&#x3C; "peek at the instance's 'a' member" &#x3C;&#x3C; endl;
  cout &#x3C;&#x3C; example_inst->a &#x3C;&#x3C; endl;
  cout &#x3C;&#x3C; "peek at the instance's 'sub' member's 't' member" &#x3C;&#x3C; endl;
  cout &#x3C;&#x3C; example_inst->sub->t &#x3C;&#x3C; endl;
}
</code></pre>
<p>I'll add a follow up article some day for analyzing some of the
llvm-ir assembly instructions that the clang compiler can emit to get a good idea
at the overhead the wrapper incurs and how to minimize it or potentially eradicate
it with optimization and inlining. If you find better ways, as I'm sure you will,
please send me an email.</p></div></div></main></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/blog/Super_Thin_RAII_Wrappers_for_C_Types/";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"app":["/app-c3527675040adf5ea2fd.js"],"component---src-components-blog-page-tsx":["/component---src-components-blog-page-tsx-6d04ce94b616cd2c5bd3.js"],"component---src-pages-3-d-tsx":["/component---src-pages-3-d-tsx-2e718283dbc8bc73f3f7.js"],"component---src-pages-404-tsx":["/component---src-pages-404-tsx-581c2129730b4589495d.js"],"component---src-pages-blog-tsx":["/component---src-pages-blog-tsx-93486d463c9297091d6d.js"],"component---src-pages-index-tsx":["/component---src-pages-index-tsx-cd461490bc8b791c6a80.js"],"component---src-pages-work-tsx":["/component---src-pages-work-tsx-c6afbfcff1a7253e790b.js"]};/*]]>*/</script><script src="/webpack-runtime-16a2198acefe0c70b60a.js" async=""></script><script src="/app-c3527675040adf5ea2fd.js" async=""></script><script src="/framework-da8c6e3ed6a1d0c32925.js" async=""></script><script src="/commons-e794e0a14ff585b098df.js" async=""></script><script src="/component---src-components-blog-page-tsx-6d04ce94b616cd2c5bd3.js" async=""></script><script src="/styles-f12963b3798c232a68f6.js" async=""></script></body></html>